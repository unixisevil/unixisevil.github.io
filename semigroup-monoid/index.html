<!DOCTYPE html>
<html lang="en">

<head>
    <title>Random Notes</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://unixisevil.github.io/style.css">
    <link rel="stylesheet" href="https://unixisevil.github.io/color/blue.css">

    <link rel="stylesheet" href="https://unixisevil.github.io/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://unixisevil.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Random Notes
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://unixisevil.github.io">blog</a></li>
            
                <li><a href="https://unixisevil.github.io/tags">tags</a></li>
            
                <li><a href="https://unixisevil.github.io/archive">archive</a></li>
            
                <li><a href="https://my.oschina.net/evilunix">old blog</a></li>
            
                <li class="active"><a href="https://unixisevil.github.io/" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://unixisevil.github.io/semigroup-monoid/">semigroup and monoid in rust</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-02-14
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/monoid/">#monoid</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/rust/">#rust</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/semigroup/">#semigroup</a></span>
    

        
        <div class="post-content">
            <p>前段时间看了看Haskell, 作为纯函数式编程语言, Haskell的根基几乎是用数学概念来构建, 比如<a href="https://en.wikipedia.org/wiki/Semigroup">Semigroup</a>, <a href="https://en.wikipedia.org/wiki/Monoid">Monoid</a>, 从这些数学定义看，这些概念有些抽象，不过从代码角度看，还是不难理解的.</p>
<p>Semigroup 和 Monoid 在Haskell 中被定义为type class(描述一类type 应该具备的行为, 类似rust的trait):</p>
<pre data-lang="haskell" style="background-color:#151515;color:#e8e8d3;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>class </span><span style="color:#ffb964;">Semigroup a </span><span>where
</span><span>  </span><span style="color:#fad07a;">(&lt;&gt;) </span><span>:: </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a
</span><span>
</span><span>class </span><span style="color:#ffb964;">Semigroup a</span><span> =&gt; </span><span style="color:#ffb964;">Monoid a </span><span>where
</span><span>  </span><span style="color:#fad07a;">mempty </span><span>:: </span><span style="color:#ffb964;">a
</span><span>  </span><span style="color:#fad07a;">mappend </span><span>:: </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a
</span><span>  </span><span style="color:#fad07a;">mconcat </span><span>:: [</span><span style="color:#ffb964;">a</span><span>] -&gt; </span><span style="color:#ffb964;">a
</span></code></pre>
<p>Semigroup 的核心行为是combine 运算符 (&lt;&gt;) :: Semigroup a =&gt; a -&gt; a -&gt; a,  combine 是二元运算, 其接收两个同类型的东西, 输出同样的东西, 只要是符合结合律的二元操作都是合法的combine 实现.  比如Integer 的 + 运算:</p>
<pre data-lang="haskell" style="background-color:#151515;color:#e8e8d3;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>instance </span><span style="color:#8fbfdc;">Semigroup Integer </span><span>where
</span><span>    </span><span style="color:#fad07a;">(&lt;&gt;)</span><span> x y = x + y
</span></code></pre>
<p>Monoid 是Semigroup 的拓展或者说是子类,  Monoid 具备combine 行为,  加上另一条行为要求: 实现Monoid 的type必须定义其identity 元素.
identity 元素的意思是 x &lt;&gt; id = x ,  id &lt;&gt; x  = x ,  任何x 与 identity 以任何order 的组合，结果都是返回x. 比如加法运算中的0，x + 0= 0 + x = 0,  乘法运算中的1, x * 1 = 1 * x =  x.</p>
<p>据说是历史原因，Monoid 先于 Semigroup 在标准库中被实现， 本来可以更简洁地被定义成:</p>
<pre data-lang="haskell" style="background-color:#151515;color:#e8e8d3;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>class </span><span style="color:#ffb964;">Semigroup a</span><span> =&gt; </span><span style="color:#ffb964;">Monoid a </span><span>where
</span><span>    </span><span style="color:#fad07a;">identity </span><span>:: </span><span style="color:#ffb964;">a
</span></code></pre>
<p>rust库<a href="https://crates.io/crates/frunk">frunk</a> 定义了Semigroup trait 和 Monoid trait. 以下是一些Semigroup 和 Monoid 的代码例子.</p>
<p>比如可以定义颜色是Semigroup 的实现:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#ffb964;">derive</span><span>(Debug, PartialEq, Eq, Copy, Clone)]
</span><span style="color:#8fbfdc;">enum </span><span style="color:#ffb964;">Color </span><span>{
</span><span>    Red,
</span><span>    Yellow,
</span><span>    Blue,
</span><span>    Green,
</span><span>    Purple,
</span><span>    Orange,
</span><span>    Brown,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Semigroup for </span><span style="color:#ffb964;">Color </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">other</span><span>: &amp;</span><span style="color:#8fbfdc;">Self</span><span>) -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">match </span><span>(</span><span style="color:#ffb964;">self</span><span>, other) {
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Blue) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Purple,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Red) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Purple,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Blue) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Green,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Green,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Red) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Orange,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Orange,
</span><span>            (a, b) </span><span style="color:#8fbfdc;">if</span><span> a == b =&gt; *a,
</span><span>            (a, b) =&gt; {
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> rbp = [</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Purple];
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> byg = [</span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Green];
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> ryo = [</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Orange];
</span><span>                </span><span style="color:#8fbfdc;">if</span><span> rbp.contains(a) &amp;&amp; rbp.contains(b) {
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Purple
</span><span>                } </span><span style="color:#8fbfdc;">else if</span><span> byg.contains(a) &amp;&amp; byg.contains(b) {
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Green
</span><span>                } </span><span style="color:#8fbfdc;">else if</span><span> ryo.contains(a) &amp;&amp; ryo.contains(b) {
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Orange
</span><span>                } </span><span style="color:#8fbfdc;">else </span><span>{
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Brown
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Color 类型的combine 实现中，定义不同的颜色如何混合形成另一种颜色.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">Events </span><span>= Vec&lt;String&gt;;
</span><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">Probs </span><span>= Vec&lt;</span><span style="color:#8fbfdc;">f64</span><span>&gt;;
</span><span>
</span><span>#[</span><span style="color:#ffb964;">derive</span><span>(Clone)]
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">Ptable </span><span>{
</span><span>    </span><span style="color:#ffb964;">events</span><span>: Events,
</span><span>    </span><span style="color:#ffb964;">probs</span><span>: Probs,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Semigroup for </span><span style="color:#ffb964;">Ptable </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">other</span><span>: &amp;</span><span style="color:#8fbfdc;">Self</span><span>) -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">match </span><span>(</span><span style="color:#ffb964;">self</span><span>, other) {
</span><span>            (a, Ptable { events, probs }) </span><span style="color:#8fbfdc;">if</span><span> events.is_empty() &amp;&amp; probs.is_empty() =&gt; a.clone(),
</span><span>            (Ptable { events, probs }, b) </span><span style="color:#8fbfdc;">if</span><span> events.is_empty() &amp;&amp; probs.is_empty() =&gt; b.clone(),
</span><span>            (
</span><span>                Ptable {
</span><span>                    events: ea,
</span><span>                    probs: pa,
</span><span>                },
</span><span>                Ptable {
</span><span>                    events: eb,
</span><span>                    probs: pb,
</span><span>                },
</span><span>            ) =&gt; {
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> em = combine_events(ea, eb);
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> pm = combine_probs(pa, pb);
</span><span>                Ptable::new(em, pm)
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Monoid for </span><span style="color:#ffb964;">Ptable </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">empty</span><span>() -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        Ptable::new(vec![], vec![])
</span><span>    }
</span><span>}
</span></code></pre>
<p>事件发生的概率可以是Monoid，A 事件发生的概率是多少， B 事件的概率是多少， A 与 B 组合发生的概率是多少， 比如硬币连抛三次的事件的概率是多少.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#ffb964;">derive</span><span>(Clone)]
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">TimeSeries </span><span>{
</span><span>    </span><span style="color:#ffb964;">ts</span><span>: Vec&lt;</span><span style="color:#8fbfdc;">i32</span><span>&gt;,
</span><span>    </span><span style="color:#ffb964;">vs</span><span>: Vec&lt;Option&lt;</span><span style="color:#8fbfdc;">f64</span><span>&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine_time_series</span><span>(</span><span style="color:#ffb964;">a</span><span>: &amp;TimeSeries, </span><span style="color:#ffb964;">b</span><span>: &amp;TimeSeries) -&gt; TimeSeries {
</span><span>    </span><span style="color:#8fbfdc;">match </span><span>(a, b) {
</span><span>        (TimeSeries { ts, vs }, b) </span><span style="color:#8fbfdc;">if</span><span> ts.is_empty() &amp;&amp; vs.is_empty() =&gt; b.clone(),
</span><span>        (a, TimeSeries { ts, vs }) </span><span style="color:#8fbfdc;">if</span><span> ts.is_empty() &amp;&amp; vs.is_empty() =&gt; a.clone(),
</span><span>        (TimeSeries { ts: t1, vs: v1 }, TimeSeries { ts: t2, vs: v2 }) =&gt; {
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> mt = t1.iter().chain(t2);
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> min = mt.clone().min().copied().unwrap();
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> max = mt.max().unwrap();
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> complete_times = min..max + </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>            </span><span style="color:#8fbfdc;">let mut</span><span> acc = BTreeMap::&lt;</span><span style="color:#8fbfdc;">i32</span><span>, </span><span style="color:#8fbfdc;">f64</span><span>&gt;::default();
</span><span>
</span><span>            </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">insert_tv_pair </span><span>= |</span><span style="color:#ffb964;">map</span><span>: &amp;</span><span style="color:#8fbfdc;">mut </span><span>BTreeMap&lt;_, _&gt;, </span><span style="color:#ffb964;">tv_pair</span><span>: (&amp;_, &amp;_)| </span><span style="color:#8fbfdc;">match</span><span> tv_pair {
</span><span>                (_, None) =&gt; {}
</span><span>                (t, Some(v)) =&gt; {
</span><span>                    map.insert(*t, *v);
</span><span>                }
</span><span>            };
</span><span>            </span><span style="color:#8fbfdc;">let mut</span><span> acc = t1.iter().zip(v1.iter()).fold(&amp;</span><span style="color:#8fbfdc;">mut</span><span> acc, |</span><span style="color:#ffb964;">acc</span><span>, </span><span style="color:#ffb964;">e</span><span>| {
</span><span>                insert_tv_pair(acc, e);
</span><span>                acc
</span><span>            });
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> acc = t2.iter().zip(v2.iter()).fold(&amp;</span><span style="color:#8fbfdc;">mut</span><span> acc, |</span><span style="color:#ffb964;">acc</span><span>, </span><span style="color:#ffb964;">e</span><span>| {
</span><span>                insert_tv_pair(acc, e);
</span><span>                acc
</span><span>            });
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> final_vs: Vec&lt;Option&lt;</span><span style="color:#8fbfdc;">f64</span><span>&gt;&gt; = complete_times
</span><span>                .clone()
</span><span>                .map(|</span><span style="color:#ffb964;">t</span><span>| acc.get(&amp;t).copied())
</span><span>                .collect();
</span><span>
</span><span>            TimeSeries {
</span><span>                ts: complete_times.collect::&lt;Vec&lt;</span><span style="color:#8fbfdc;">i32</span><span>&gt;&gt;(),
</span><span>                vs: final_vs,
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Semigroup for </span><span style="color:#ffb964;">TimeSeries </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">other</span><span>: &amp;</span><span style="color:#8fbfdc;">Self</span><span>) -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        combine_time_series(</span><span style="color:#ffb964;">self</span><span>, other)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Monoid for </span><span style="color:#ffb964;">TimeSeries </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">empty</span><span>() -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>            ts: vec![],
</span><span>            vs: vec![],
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>时间序列可以是一种Monoid, 某个逻辑时间点上的值可能有缺失, 如何合并不同的time series， 时间序列类型上可以定义一些常见的操作.</p>
<p><a href="https://gist.github.com/unixisevil/badc8445d7a165d9abb8ec54147491e8">full source code</a></p>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://unixisevil.github.io/profile-rust/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Profiling Rust code using Samply</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://unixisevil.github.io/laziness/">
                            <span class="button__text">Traps of Laziness</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
