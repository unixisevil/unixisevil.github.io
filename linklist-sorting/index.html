<!DOCTYPE html>
<html lang="en">

<head>
    <title>Random Notes</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://unixisevil.github.io/style.css">
    <link rel="stylesheet" href="https://unixisevil.github.io/color/blue.css">

    <link rel="stylesheet" href="https://unixisevil.github.io/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://unixisevil.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Random Notes
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://unixisevil.github.io">blog</a></li>
            
                <li><a href="https://unixisevil.github.io/tags">tags</a></li>
            
                <li><a href="https://unixisevil.github.io/archive">archive</a></li>
            
                <li><a href="https://my.oschina.net/evilunix">old blog</a></li>
            
                <li class="active"><a href="https://unixisevil.github.io/" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
    <div class="post">
        
    <h1 class="post-title"><a href="https://unixisevil.github.io/linklist-sorting/">link list sorting</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2023-10-24
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/golang/">#golang</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/link-list/">#link list</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/sorting/">#sorting</a></span>
    

        
        <div class="post-content">
            <p>偶然读到了Putty作者<a href="https://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html">Simon Tatham的这篇blog</a>, 他这个自底向上，
只需要常量空间的链表merge sort 比较有意思, 跟我之前了解的自顶向下和自底向上的两个版本不太一样, 于是把他这个C的实现移植到golang，
写了简单test和benchmark, 跟之前了解的版本做下对比</p>
<p>正好golang 1.21 发布后，在标准库引入了<a href="https://pkg.go.dev/slices">slice</a>, <a href="https://pkg.go.dev/cmp">cmp</a>等便利工具可以使用</p>
<p>sortlist.go:</p>
<pre data-lang="golang" style="background-color:#151515;color:#e8e8d3;" class="language-golang "><code class="language-golang" data-lang="golang"><span>
</span><span>package main
</span><span>
</span><span>import (
</span><span>	&quot;cmp&quot;
</span><span>	&quot;fmt&quot;
</span><span>	&quot;math/rand&quot;
</span><span>	&quot;slices&quot;
</span><span>)
</span><span>
</span><span>type node[E cmp.Ordered] struct {
</span><span>	next *node[E]
</span><span>	data E
</span><span>}
</span><span>
</span><span>func prependList[E cmp.Ordered](href **node[E], data E) {
</span><span>	new := &amp;node[E]{data: data}
</span><span>	new.next = *href
</span><span>	*href = new
</span><span>}
</span><span>
</span><span>func appendList[E cmp.Ordered](href **node[E], data E) {
</span><span>	new := &amp;node[E]{data: data}
</span><span>	tail := href
</span><span>	for ; *tail != nil; tail = &amp;(*tail).next {
</span><span>	}
</span><span>	*tail = new
</span><span>}
</span><span>
</span><span>func listIsSorted[E cmp.Ordered](h *node[E]) bool {
</span><span>	sorted := true
</span><span>	for c := h; c != nil; c = c.next {
</span><span>		if c.next != nil &amp;&amp; cmp.Compare(c.data, c.next.data) == 1 {
</span><span>			sorted = false
</span><span>			break
</span><span>		}
</span><span>	}
</span><span>	return sorted
</span><span>}
</span><span>
</span><span>func walk[E cmp.Ordered](h *node[E]) {
</span><span>	for c := h; c != nil; c = c.next {
</span><span>		fmt.Printf(&quot;%v &quot;, c.data)
</span><span>	}
</span><span>	fmt.Println()
</span><span>}
</span><span>
</span><span>func inPlaceMergeSort[E cmp.Ordered](list *node[E]) *node[E] {
</span><span>	var (
</span><span>		p     *node[E]
</span><span>		q     *node[E]
</span><span>		e     *node[E]
</span><span>		tail  *node[E]
</span><span>		psize int
</span><span>		qsize int
</span><span>	)
</span><span>	if list == nil {
</span><span>		return nil
</span><span>	}
</span><span>	insize := 1
</span><span>	for {
</span><span>		p = list
</span><span>		list = nil
</span><span>		tail = nil
</span><span>		nmerges := 0
</span><span>		for p != nil {
</span><span>			nmerges++
</span><span>			q = p
</span><span>			psize = 0
</span><span>			for i := 0; i &lt; insize; i++ {
</span><span>				psize++
</span><span>				q = q.next
</span><span>				if q == nil {
</span><span>					break
</span><span>				}
</span><span>			}
</span><span>			qsize = insize
</span><span>			for psize &gt; 0 || (qsize &gt; 0 &amp;&amp; q != nil) {
</span><span>				if psize == 0 {
</span><span>					e = q
</span><span>					q = q.next
</span><span>					qsize--
</span><span>				} else if qsize == 0 || q == nil {
</span><span>					e = p
</span><span>					p = p.next
</span><span>					psize--
</span><span>				} else if cmp.Compare(p.data, q.data) &lt;= 0 {
</span><span>					e = p
</span><span>					p = p.next
</span><span>					psize--
</span><span>				} else {
</span><span>					e = q
</span><span>					q = q.next
</span><span>					qsize--
</span><span>				}
</span><span>				if tail != nil {
</span><span>					tail.next = e
</span><span>				} else {
</span><span>					list = e
</span><span>				}
</span><span>				tail = e
</span><span>			}
</span><span>			p = q
</span><span>		}
</span><span>		tail.next = nil
</span><span>		if nmerges &lt;= 1 {
</span><span>			return list
</span><span>		}
</span><span>		insize *= 2
</span><span>	}
</span><span>}
</span><span>
</span><span>func insertSort[E cmp.Ordered](c *node[E]) *node[E] {
</span><span>	insert := func(href **node[E], new *node[E]) {
</span><span>		if *href == nil || !cmp.Less((*href).data, new.data) {
</span><span>			new.next = *href
</span><span>			*href = new
</span><span>		} else {
</span><span>			c := *href
</span><span>			for c.next != nil &amp;&amp; cmp.Less(c.next.data, new.data) {
</span><span>				c = c.next
</span><span>			}
</span><span>			new.next = c.next
</span><span>			c.next = new
</span><span>		}
</span><span>	}
</span><span>
</span><span>	var sorted *node[E]
</span><span>	for c != nil {
</span><span>		next := c.next
</span><span>		insert(&amp;sorted, c)
</span><span>		c = next
</span><span>	}
</span><span>	return sorted
</span><span>}
</span><span>
</span><span>func merge[E cmp.Ordered](a, b *node[E]) *node[E] {
</span><span>	var dummy node[E]
</span><span>	c := &amp;dummy
</span><span>	for a != nil &amp;&amp; b != nil {
</span><span>		if cmp.Less(a.data, b.data) {
</span><span>			c.next = a
</span><span>			c = a
</span><span>			a = a.next
</span><span>		} else {
</span><span>			c.next = b
</span><span>			c = b
</span><span>			b = b.next
</span><span>		}
</span><span>	}
</span><span>	if a == nil {
</span><span>		c.next = b
</span><span>	} else {
</span><span>		c.next = a
</span><span>	}
</span><span>	c = dummy.next
</span><span>	dummy.next = nil
</span><span>	return c
</span><span>}
</span><span>
</span><span>func topDownMergeSort[E cmp.Ordered](c *node[E]) *node[E] {
</span><span>	var (
</span><span>		a *node[E]
</span><span>		b *node[E]
</span><span>	)
</span><span>	// base case(empty list, or single elem list)
</span><span>	if c == nil || c.next == nil {
</span><span>		return c
</span><span>	}
</span><span>	a = c
</span><span>	b = c.next
</span><span>	for b != nil &amp;&amp; b.next != nil {
</span><span>		c = c.next
</span><span>		b = b.next.next
</span><span>	}
</span><span>	b = c.next
</span><span>	c.next = nil
</span><span>	return merge(topDownMergeSort(a), topDownMergeSort(b))
</span><span>}
</span><span>
</span><span>func bottomUpMergeSort[E cmp.Ordered](c *node[E]) *node[E] {
</span><span>	var (
</span><span>		queue []*node[E]
</span><span>		t     *node[E]
</span><span>	)
</span><span>	for ; c != nil; c = t {
</span><span>		t = c.next
</span><span>		c.next = nil
</span><span>		queue = append(queue, c)
</span><span>	}
</span><span>	c = queue[0]
</span><span>	queue = queue[1:]
</span><span>	for len(queue) &gt; 0 {
</span><span>		queue = append(queue, c)
</span><span>		a := queue[0]
</span><span>		b := queue[1]
</span><span>		queue = queue[2:]
</span><span>		c = merge(a, b)
</span><span>	}
</span><span>	return c
</span><span>}
</span><span>
</span><span>func makeRndSlice(len, min, max int) []int {
</span><span>	rs := make([]int, len)
</span><span>	for i := 0; i &lt; len; i++ {
</span><span>		rs[i] = min + rand.Intn(max-min+1)
</span><span>	}
</span><span>	return rs
</span><span>}
</span><span>
</span><span>func makeAscList(len, min, max int) *node[int] {
</span><span>	var list *node[int]
</span><span>	rs := makeRndSlice(len, min, max)
</span><span>	slices.Sort(rs)
</span><span>	slices.Reverse(rs)
</span><span>	for _, e := range rs {
</span><span>		prependList(&amp;list, e)
</span><span>	}
</span><span>	return list
</span><span>}
</span><span>
</span><span>func makeDescList(len, min, max int) *node[int] {
</span><span>	var list *node[int]
</span><span>	rs := makeRndSlice(len, min, max)
</span><span>	slices.Sort(rs)
</span><span>	for _, e := range rs {
</span><span>		prependList(&amp;list, e)
</span><span>	}
</span><span>	return list
</span><span>}
</span><span>
</span><span>func makeRandList(len, min, max int) *node[int] {
</span><span>	var list *node[int]
</span><span>	rs := makeRndSlice(len, min, max)
</span><span>	for _, e := range rs {
</span><span>		prependList(&amp;list, e)
</span><span>	}
</span><span>	return list
</span><span>}
</span><span>
</span><span>func main() {
</span><span>	list1 := makeRandList(10, 10, 99)
</span><span>	walk(list1)
</span><span>	list1 = insertSort(list1)
</span><span>	walk(list1)
</span><span>
</span><span>	list2 := makeRandList(10, 10, 99)
</span><span>	walk(list2)
</span><span>	list2 = topDownMergeSort(list2)
</span><span>	walk(list2)
</span><span>
</span><span>	list3 := makeRandList(10, 10, 99)
</span><span>	walk(list3)
</span><span>	list3 = bottomUpMergeSort(list3)
</span><span>	walk(list3)
</span><span>
</span><span>	list4 := makeRandList(10, 10, 99)
</span><span>	walk(list4)
</span><span>	list4 = inPlaceMergeSort(list4)
</span><span>	walk(list4)
</span><span>}
</span></code></pre>
<p>上述代码中insertSort 是链表的插入排序, topDownMergeSort 是自顶向下递归的merge sort, bottomUpMergeSort是自底向上迭代的merge sort,
inPlaceMergeSort 是Simon Tatham 的版本</p>
<p>sortlist_test.go:</p>
<pre data-lang="golang" style="background-color:#151515;color:#e8e8d3;" class="language-golang "><code class="language-golang" data-lang="golang"><span>
</span><span>package main
</span><span>
</span><span>import (
</span><span>	&quot;testing&quot;
</span><span>)
</span><span>
</span><span>func testHelper(t *testing.T, sortFn func(*node[int]) *node[int]) {
</span><span>	ascList := makeAscList(10, 1, 100)
</span><span>	ascList = sortFn(ascList)
</span><span>	if !listIsSorted(ascList) {
</span><span>		t.Fail()
</span><span>	}
</span><span>
</span><span>	dscList := makeDescList(10, 1, 100)
</span><span>	dscList = sortFn(dscList)
</span><span>	if !listIsSorted(dscList) {
</span><span>		t.Fail()
</span><span>	}
</span><span>
</span><span>	rndList := makeRandList(10, 100, 500)
</span><span>	rndList = sortFn(rndList)
</span><span>	if !listIsSorted(rndList) {
</span><span>		t.Fail()
</span><span>	}
</span><span>}
</span><span>
</span><span>func TestInsertSort(t *testing.T) {
</span><span>	testHelper(t, insertSort[int])
</span><span>}
</span><span>
</span><span>func TestTopDownMergeSort(t *testing.T) {
</span><span>	testHelper(t, topDownMergeSort[int])
</span><span>}
</span><span>
</span><span>func TestBottomUpMergeSort(t *testing.T) {
</span><span>	testHelper(t, bottomUpMergeSort[int])
</span><span>}
</span><span>
</span><span>func TestInPlaceMergeSort(t *testing.T) {
</span><span>	testHelper(t, inPlaceMergeSort[int])
</span><span>}
</span><span>
</span><span>var Sink *node[int]
</span><span>
</span><span>func benchHelper(b *testing.B, sortFn func(*node[int]) *node[int]) {
</span><span>	for _, bcase := range []struct {
</span><span>		name         string
</span><span>		inputGenFunc func() *node[int]
</span><span>	}{
</span><span>		{&quot;smallAscList&quot;, func() *node[int] { return makeAscList(50, 10, 100) }},
</span><span>		{&quot;smallDescList&quot;, func() *node[int] { return makeDescList(50, 10, 100) }},
</span><span>		{&quot;smallRndList&quot;, func() *node[int] { return makeRandList(50, 10, 100) }},
</span><span>		{&quot;bigAscList&quot;, func() *node[int] { return makeAscList(1e5, 1, 1e4) }},
</span><span>		{&quot;bigDescList&quot;, func() *node[int] { return makeDescList(1e5, 1, 1e4) }},
</span><span>		{&quot;bigRndList&quot;, func() *node[int] { return makeRandList(1e5, 1, 1e5) }},
</span><span>	} {
</span><span>		b.Run(bcase.name, func(b *testing.B) {
</span><span>			b.ReportAllocs()
</span><span>			var s *node[int]
</span><span>			for i := 0; i &lt; b.N; i++ {
</span><span>				b.StopTimer()
</span><span>				input := bcase.inputGenFunc()
</span><span>				b.StartTimer()
</span><span>				s = sortFn(input)
</span><span>			}
</span><span>			Sink = s
</span><span>		})
</span><span>	}
</span><span>}
</span><span>
</span><span>func BenchmarkInsertSort(b *testing.B) {
</span><span>	benchHelper(b, insertSort[int])
</span><span>}
</span><span>
</span><span>func BenchmarkTopDownMergeSort(b *testing.B) {
</span><span>	benchHelper(b, topDownMergeSort[int])
</span><span>}
</span><span>
</span><span>func BenchmarkBottomUpMergeSort(b *testing.B) {
</span><span>	benchHelper(b, bottomUpMergeSort[int])
</span><span>}
</span><span>
</span><span>func BenchmarkInPlaceMergeSort(b *testing.B) {
</span><span>	benchHelper(b, inPlaceMergeSort[int])
</span><span>}
</span></code></pre>
<p>一次benchmark 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">BenchmarkInsertSort/smallAscList-12</span><span>         	  834589	      1442 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInsertSort/smallDescList-12</span><span>        	 6429494	       186.8 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInsertSort/smallRndList-12</span><span>         	 1000000	      1145 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInsertSort/bigAscList-12</span><span>           	       1	7555973814 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInsertSort/bigDescList-12</span><span>          	    4516	    266626 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInsertSort/bigRndList-12</span><span>           	       1	20278468050 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkTopDownMergeSort/smallAscList-12</span><span>   	  442106	      2426 ns/op	     784 B/op	      49 allocs/op
</span><span style="color:#ffb964;">BenchmarkTopDownMergeSort/smallDescList-12</span><span>  	  557928	      2297 ns/op	     784 B/op	      49 allocs/op
</span><span style="color:#ffb964;">BenchmarkTopDownMergeSort/smallRndList-12</span><span>   	  353748	      3175 ns/op	     784 B/op	      49 allocs/op
</span><span style="color:#ffb964;">BenchmarkTopDownMergeSort/bigAscList-12</span><span>     	     135	   8902250 ns/op	 1599991 B/op	   99999 allocs/op
</span><span style="color:#ffb964;">BenchmarkTopDownMergeSort/bigDescList-12</span><span>    	     147	   8189749 ns/op	 1599990 B/op	   99999 allocs/op
</span><span style="color:#ffb964;">BenchmarkTopDownMergeSort/bigRndList-12</span><span>     	      79	  14935899 ns/op	 1599990 B/op	   99999 allocs/op
</span><span style="color:#ffb964;">BenchmarkBottomUpMergeSort/smallAscList-12</span><span>  	  352664	      3374 ns/op	    2376 B/op	      57 allocs/op
</span><span style="color:#ffb964;">BenchmarkBottomUpMergeSort/smallDescList-12</span><span> 	  358518	      3300 ns/op	    2376 B/op	      57 allocs/op
</span><span style="color:#ffb964;">BenchmarkBottomUpMergeSort/smallRndList-12</span><span>  	  285111	      4122 ns/op	    2376 B/op	      57 allocs/op
</span><span style="color:#ffb964;">BenchmarkBottomUpMergeSort/bigAscList-12</span><span>    	      73	  14356156 ns/op	 9057681 B/op	  100042 allocs/op
</span><span style="color:#ffb964;">BenchmarkBottomUpMergeSort/bigDescList-12</span><span>   	      86	  13416789 ns/op	 9057660 B/op	  100042 allocs/op
</span><span style="color:#ffb964;">BenchmarkBottomUpMergeSort/bigRndList-12</span><span>    	      68	  21171545 ns/op	 9057652 B/op	  100042 allocs/op
</span><span style="color:#ffb964;">BenchmarkInPlaceMergeSort/smallAscList-12</span><span>   	 1286823	       928.9 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInPlaceMergeSort/smallDescList-12</span><span>  	 1000000	      1107 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInPlaceMergeSort/smallRndList-12</span><span>   	  646136	      1865 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInPlaceMergeSort/bigAscList-12</span><span>     	     285	   4114096 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInPlaceMergeSort/bigDescList-12</span><span>    	     232	   5074325 ns/op	       0 B/op	       0 allocs/op
</span><span style="color:#ffb964;">BenchmarkInPlaceMergeSort/bigRndList-12</span><span>     	      84	  13954904 ns/op	       8 B/op	       0 allocs/op
</span></code></pre>

        </div>

        
        <div class="pagination">
            <div class="pagination__title">
                <span class="pagination__title-h">Thanks for reading! Read other posts?</span>
                <hr />
            </div>
            <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://unixisevil.github.io/matmul/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">矩阵乘法</span>
                        </a>
                    </span>
                
                
                    <span class="button next">
                        <a href="https://unixisevil.github.io/flatten-parse-tree/">
                            <span class="button__text">carbon 如何表达解析树</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
        </div>
    
    </div>

    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
