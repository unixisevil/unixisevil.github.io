<!DOCTYPE html>
<html lang="en">

<head>
    <title>Random Notes</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://unixisevil.github.io/style.css">
    <link rel="stylesheet" href="https://unixisevil.github.io/color/blue.css">

    <link rel="stylesheet" href="https://unixisevil.github.io/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://unixisevil.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Random Notes
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://unixisevil.github.io">blog</a></li>
            
                <li><a href="https://unixisevil.github.io/tags">tags</a></li>
            
                <li><a href="https://unixisevil.github.io/archive">archive</a></li>
            
                <li><a href="https://my.oschina.net/evilunix">old blog</a></li>
            
                <li class="active"><a href="https://unixisevil.github.io/" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
        <div class="posts">
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://unixisevil.github.io/wordfreq-in-elixir/">playing around with text processing in elixir</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-10-30
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/elixir/">#elixir</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/ets-table/">#ets table</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/string/">#string</a></span>
    

                    
        <div class="post-content">
            <p>最近读到了一篇关于<a href="https://blog.jola.dev/posts/elixir-string-processing-optimization">Elixir String Processing Optimization</a> 的文章， 借着这个机会开始动手写elixir 代码，熟悉一下elixir标准库相关api的使用.</p>
<p>这是作者呈现的第一段代码:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span style="color:#ffb964;">IO</span><span>.stream(</span><span style="color:#7697d6;">:stdio</span><span>, </span><span style="color:#7697d6;">:line</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Stream</span><span>.flat_map(&amp;</span><span style="color:#ffb964;">String</span><span>.split/</span><span style="color:#cf6a4c;">1</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.reduce(%{}, </span><span style="color:#8fbfdc;">fn</span><span> x, acc -&gt; </span><span style="color:#ffb964;">Map</span><span>.update(acc, x, </span><span style="color:#cf6a4c;">1</span><span>, &amp;(</span><span style="color:#7697d6;">&amp;1 </span><span>+ </span><span style="color:#cf6a4c;">1</span><span>)) </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.sort(</span><span style="color:#8fbfdc;">fn </span><span>{_, a}, {_, b} -&gt; b &lt; a </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt;
</span><span>  </span><span style="color:#ffb964;">IO</span><span>.puts(</span><span style="color:#ffb964;">String</span><span>.pad_leading(</span><span style="color:#ffb964;">Integer</span><span>.to_string(count), </span><span style="color:#cf6a4c;">8</span><span>) &lt;&gt; </span><span style="color:#556633;">&quot; &quot; </span><span>&lt;&gt; word)
</span><span style="color:#8fbfdc;">end</span><span>)
</span></code></pre>
<p>的确是短小精炼，流畅优雅, 不过速度很慢， 在我的机器上运行了1372.10s, 作者也解释了相关的原因，我也学习到了一些elixir 相关知识.</p>
<p>奇怪的是作者呈现的最后一段elixir code, 使用第三方库flow, 还是很慢， 在我机器上运行了1321.68s, 本来期待有很大改进的， 在阅读了一会儿<a href="https://hexdocs.pm/flow/Flow.html#module-performance-discussions">Flow的这部分文档</a>后， 我测试了这段代码:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span>parent = self()
</span><span>pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern([</span><span style="color:#556633;">&quot; &quot;</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>])
</span><span>
</span><span style="color:#ffb964;">System</span><span>.argv()
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.at(</span><span style="color:#cf6a4c;">0</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">../words-llvm8.0.txt</span><span style="color:#556633;">&quot;</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">File</span><span>.stream!(</span><span style="color:#7697d6;">read_ahead: </span><span style="color:#cf6a4c;">1_024_000</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Flow</span><span>.from_enumerable()
</span><span>|&gt; </span><span style="color:#ffb964;">Flow</span><span>.flat_map(&amp;</span><span style="color:#ffb964;">String</span><span>.split(</span><span style="color:#7697d6;">&amp;1</span><span>, pattern, </span><span style="color:#7697d6;">trim: </span><span>true))
</span><span>|&gt; </span><span style="color:#ffb964;">Flow</span><span>.partition(</span><span style="color:#7697d6;">min_demand: </span><span style="color:#cf6a4c;">1_000_000</span><span>, </span><span style="color:#7697d6;">max_demand: </span><span style="color:#cf6a4c;">3_468_009</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Flow</span><span>.reduce(</span><span style="color:#8fbfdc;">fn </span><span>-&gt; </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, []) </span><span style="color:#8fbfdc;">end</span><span>, </span><span style="color:#8fbfdc;">fn</span><span> word, ets -&gt;
</span><span>  </span><span style="color:#7697d6;">:ets</span><span>.update_counter(ets, word, {</span><span style="color:#cf6a4c;">2</span><span>, </span><span style="color:#cf6a4c;">1</span><span>}, {word, </span><span style="color:#cf6a4c;">0</span><span>})
</span><span>  ets
</span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Flow</span><span>.on_trigger(</span><span style="color:#8fbfdc;">fn</span><span> ets -&gt;
</span><span>  </span><span style="color:#7697d6;">:ets</span><span>.give_away(ets, parent, [])
</span><span>  {[ets], </span><span style="color:#7697d6;">:new_reduce_state_which_wont_be_used</span><span>}
</span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.flat_map(&amp;</span><span style="color:#7697d6;">:ets</span><span>.tab2list/</span><span style="color:#cf6a4c;">1</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.sort(</span><span style="color:#8fbfdc;">fn </span><span>{_, a}, {_, b} -&gt; b &lt; a </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.map(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt;
</span><span>  [</span><span style="color:#ffb964;">Integer</span><span>.to_string(count), </span><span style="color:#556633;">&quot; &quot;</span><span>, word, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>]
</span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">IO</span><span>.binwrite()
</span></code></pre>
<p>使用hyperfine的cold cache benchmark 方法:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">hyperfine --prepare </span><span style="color:#556633;">&#39;</span><span style="color:#99ad6a;">sync; echo 3 | sudo tee /proc/sys/vm/drop_caches</span><span style="color:#556633;">&#39;  &#39;</span><span style="color:#99ad6a;">some command</span><span style="color:#556633;">&#39;
</span></code></pre>
<p>结果是:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: mix run lib/words_flow.ex
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      5.749 s ±  0.105 s    </span><span style="color:#8fbfdc;">[</span><span>User: 40.729 s, System: 3.827 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    5.591 s …  5.897 s    10 runs
</span></code></pre>
<p>通过调整参数min_demand, max_demand 可以控制stage 之间的流动数据的数目, 这里max_demand 我选择了(the number of words in this doc) / (the number of virtual cores you have).</p>
<p>如果只使用标准库Task模块的async_stream， 做并行任务处理，效果会是如何？ 带着这个问题，开启了一轮试验.</p>
<p>wordfreq_oneline_task.exs:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span style="color:#8fbfdc;">defmodule </span><span style="color:#ffb964;">WordFreq </span><span style="color:#8fbfdc;">do
</span><span>  </span><span style="color:#8fbfdc;">def </span><span style="color:#fad07a;">start_count</span><span>(fname) </span><span style="color:#8fbfdc;">do
</span><span>    table = </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, [</span><span style="color:#7697d6;">:public</span><span>, {</span><span style="color:#7697d6;">:write_concurrency</span><span>, true}])
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern([</span><span style="color:#556633;">&quot; &quot;</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>])
</span><span>
</span><span>    count_per_line = </span><span style="color:#8fbfdc;">fn</span><span> line -&gt;
</span><span>      line
</span><span>      |&gt; </span><span style="color:#ffb964;">String</span><span>.split(pattern, </span><span style="color:#7697d6;">trim: </span><span>true)
</span><span>      |&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(&amp;</span><span style="color:#7697d6;">:ets</span><span>.update_counter(table, </span><span style="color:#7697d6;">&amp;1</span><span>, {</span><span style="color:#cf6a4c;">2</span><span>, </span><span style="color:#cf6a4c;">1</span><span>}, {</span><span style="color:#7697d6;">&amp;1</span><span>, </span><span style="color:#cf6a4c;">0</span><span>}))
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    </span><span style="color:#ffb964;">File</span><span>.stream!(fname, </span><span style="color:#7697d6;">read_ahead: </span><span style="color:#cf6a4c;">1_024_000</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Task</span><span>.async_stream(count_per_line, </span><span style="color:#7697d6;">ordered: </span><span>false, </span><span style="color:#7697d6;">on_timeout: :exit</span><span>, </span><span style="color:#7697d6;">timeout: :infinity</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Stream</span><span>.run()
</span><span>
</span><span>    </span><span style="color:#7697d6;">:ets</span><span>.tab2list(table)
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.sort(</span><span style="color:#8fbfdc;">fn </span><span>{_, a}, {_, b} -&gt; a &gt; b </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.map(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt;
</span><span>      [</span><span style="color:#ffb964;">Integer</span><span>.to_string(count), </span><span style="color:#556633;">&quot; &quot;</span><span>, word, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>]
</span><span>    </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">IO</span><span>.binwrite()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span style="color:#8fbfdc;">end
</span><span>
</span><span style="color:#ffb964;">System</span><span>.argv()
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.at(</span><span style="color:#cf6a4c;">0</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">./words-llvm8.0.txt</span><span style="color:#556633;">&quot;</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">WordFreq</span><span>.start_count()
</span></code></pre>
<p>每个beam process 以一行的粒度接收任务处理， 结果是:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: elixir wordfreq_oneline_task.exs
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):     16.991 s ±  0.235 s    </span><span style="color:#8fbfdc;">[</span><span>User: 35.676 s, System: 1.014 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):   16.741 s … 17.393 s    10 runs
</span></code></pre>
<p>wordfreq_multilines_task.exs:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span style="color:#8fbfdc;">defmodule </span><span style="color:#ffb964;">WordFreq </span><span style="color:#8fbfdc;">do
</span><span>  </span><span style="color:#8fbfdc;">def </span><span style="color:#fad07a;">start_count</span><span>(fname) </span><span style="color:#8fbfdc;">do
</span><span>    table = </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, [</span><span style="color:#7697d6;">:public</span><span>, {</span><span style="color:#7697d6;">:write_concurrency</span><span>, true}])
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern([</span><span style="color:#556633;">&quot; &quot;</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>])
</span><span>
</span><span>    count_multi_lines = </span><span style="color:#8fbfdc;">fn</span><span> lines -&gt;
</span><span>      lines
</span><span>      |&gt; </span><span style="color:#ffb964;">Stream</span><span>.flat_map(&amp;</span><span style="color:#ffb964;">String</span><span>.split(</span><span style="color:#7697d6;">&amp;1</span><span>, pattern, </span><span style="color:#7697d6;">trim: </span><span>true))
</span><span>      |&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(&amp;</span><span style="color:#7697d6;">:ets</span><span>.update_counter(table, </span><span style="color:#7697d6;">&amp;1</span><span>, {</span><span style="color:#cf6a4c;">2</span><span>, </span><span style="color:#cf6a4c;">1</span><span>}, {</span><span style="color:#7697d6;">&amp;1</span><span>, </span><span style="color:#cf6a4c;">0</span><span>}))
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    </span><span style="color:#ffb964;">File</span><span>.stream!(fname, </span><span style="color:#7697d6;">read_ahead: </span><span style="color:#cf6a4c;">1_024_000</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Stream</span><span>.chunk_every(</span><span style="color:#cf6a4c;">151_589</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Task</span><span>.async_stream(count_multi_lines, </span><span style="color:#7697d6;">ordered: </span><span>false, </span><span style="color:#7697d6;">on_timeout: :exit</span><span>, </span><span style="color:#7697d6;">timeout: :infinity</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Stream</span><span>.run()
</span><span>
</span><span>    </span><span style="color:#7697d6;">:ets</span><span>.tab2list(table)
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.sort(</span><span style="color:#8fbfdc;">fn </span><span>{_, a}, {_, b} -&gt; a &gt; b </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.map(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt;
</span><span>      [</span><span style="color:#ffb964;">Integer</span><span>.to_string(count), </span><span style="color:#556633;">&quot; &quot;</span><span>, word, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>]
</span><span>    </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">IO</span><span>.binwrite()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span style="color:#8fbfdc;">end
</span><span>
</span><span style="color:#ffb964;">System</span><span>.argv()
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.at(</span><span style="color:#cf6a4c;">0</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">./words-llvm8.0.txt</span><span style="color:#556633;">&quot;</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">WordFreq</span><span>.start_count()
</span></code></pre>
<p>每个beam process 以多行粒度接收任务, 这里chunk_every的参数 = (lines of this doc) / (the number of virtual cores you have). bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: elixir wordfreq_multilines_task.exs
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      5.439 s ±  0.051 s    </span><span style="color:#8fbfdc;">[</span><span>User: 15.974 s, System: 1.053 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    5.367 s …  5.529 s    10 runs
</span></code></pre>
<p>wordfreq_chunkread.exs:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span style="color:#8fbfdc;">defmodule </span><span style="color:#ffb964;">WordFreq </span><span style="color:#8fbfdc;">do
</span><span>  </span><span style="color:#8fbfdc;">defp </span><span style="color:#fad07a;">line_stream_from_file</span><span>(path, chunk_size) </span><span style="color:#8fbfdc;">do
</span><span>    path
</span><span>    |&gt; </span><span style="color:#ffb964;">File</span><span>.stream!(chunk_size, </span><span style="color:#7697d6;">read_ahead:</span><span> chunk_size)
</span><span>    |&gt; bin_stream_to_line_stream()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">defp </span><span style="color:#fad07a;">line_stream_from_stdin</span><span>(chunk_size) </span><span style="color:#8fbfdc;">do
</span><span>    </span><span style="color:#ffb964;">IO</span><span>.binstream(</span><span style="color:#7697d6;">:stdio</span><span>, chunk_size) |&gt; bin_stream_to_line_stream()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">defp </span><span style="color:#fad07a;">bin_stream_to_line_stream</span><span>(bin_stream) </span><span style="color:#8fbfdc;">do
</span><span>    start_fn = </span><span style="color:#8fbfdc;">fn </span><span>-&gt; </span><span style="color:#556633;">&quot;&quot; </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>)
</span><span>
</span><span>    reducer_fn = </span><span style="color:#8fbfdc;">fn</span><span> chunk, acc -&gt;
</span><span style="color:#888888;">      # IO.inspect(chunk, label: &quot;chunk&quot;, limit: :infinity)
</span><span>      [r | lines] =
</span><span>        (acc &lt;&gt; chunk)
</span><span>        |&gt; </span><span style="color:#ffb964;">String</span><span>.split(pattern)
</span><span style="color:#888888;">        # |&gt; IO.inspect(label: &quot;list&quot;, limit: :infinity)
</span><span>        |&gt; </span><span style="color:#ffb964;">Enum</span><span>.reverse()
</span><span>
</span><span>      {lines, r}
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    last_fn = </span><span style="color:#8fbfdc;">fn</span><span> acc -&gt;
</span><span>      {[acc], acc}
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    after_fn = </span><span style="color:#8fbfdc;">fn</span><span> acc -&gt;
</span><span>      acc
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    </span><span style="color:#ffb964;">Stream</span><span>.transform(bin_stream, start_fn, reducer_fn, last_fn, after_fn)
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">def </span><span style="color:#fad07a;">start_count</span><span>(fname) </span><span style="color:#8fbfdc;">do
</span><span>    table = </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, [</span><span style="color:#7697d6;">:public</span><span>, {</span><span style="color:#7697d6;">:write_concurrency</span><span>, true}])
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern(</span><span style="color:#556633;">&quot; &quot;</span><span>)
</span><span>
</span><span>    count_per_chunk = </span><span style="color:#8fbfdc;">fn</span><span> lines -&gt;
</span><span>      lines
</span><span>      |&gt; </span><span style="color:#ffb964;">Stream</span><span>.flat_map(&amp;</span><span style="color:#ffb964;">String</span><span>.split(</span><span style="color:#7697d6;">&amp;1</span><span>, pattern, </span><span style="color:#7697d6;">trim: </span><span>true))
</span><span>      |&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(&amp;</span><span style="color:#7697d6;">:ets</span><span>.update_counter(table, </span><span style="color:#7697d6;">&amp;1</span><span>, {</span><span style="color:#cf6a4c;">2</span><span>, </span><span style="color:#cf6a4c;">1</span><span>}, {</span><span style="color:#7697d6;">&amp;1</span><span>, </span><span style="color:#cf6a4c;">0</span><span>}))
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    line_stream_from_file(fname, </span><span style="color:#cf6a4c;">1_024_000</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Stream</span><span>.chunk_every(</span><span style="color:#cf6a4c;">151_589</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Task</span><span>.async_stream(count_per_chunk, </span><span style="color:#7697d6;">ordered: </span><span>false, </span><span style="color:#7697d6;">on_timeout: :exit</span><span>, </span><span style="color:#7697d6;">timeout: :infinity</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Stream</span><span>.run()
</span><span>
</span><span>    </span><span style="color:#7697d6;">:ets</span><span>.tab2list(table)
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.sort(</span><span style="color:#8fbfdc;">fn </span><span>{_, a}, {_, b} -&gt; a &gt; b </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.map(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt;
</span><span>      [</span><span style="color:#ffb964;">Integer</span><span>.to_string(count), </span><span style="color:#556633;">&quot; &quot;</span><span>, word, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>]
</span><span>    </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">IO</span><span>.binwrite()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span style="color:#8fbfdc;">end
</span><span>
</span><span style="color:#ffb964;">System</span><span>.argv()
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.at(</span><span style="color:#cf6a4c;">0</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">./words-llvm8.0.txt</span><span style="color:#556633;">&quot;</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">WordFreq</span><span>.start_count()
</span></code></pre>
<p>之前一直使用File.stream! 函数递送文本行流, 这里开始切换使用binary chunk 粒度读取文件, 但是这种方式可能会出现单词撕裂的情况，所以bin_stream_to_line_stream 函数会把binary chunk stream转换成line stream.  bin_stream_to_line_stream 使用强大的Stream.transform/5 函数完成此目的，
主要是reducer_fn 函数来实现， 每递送一个binary chunk 过来， 尝试分割，分割结果的最后一行可能是一个不完整的行，需要留下来，与下一次递送过来的binary chunk 合并继续分割. bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: elixir wordfreq_chunkread.exs
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      3.683 s ±  0.087 s    </span><span style="color:#8fbfdc;">[</span><span>User: 17.650 s, System: 1.049 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    3.545 s …  3.851 s    10 runs
</span></code></pre>
<p>wordfreq_chunkread_multiets.exs:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span style="color:#8fbfdc;">defmodule </span><span style="color:#ffb964;">WordFreq </span><span style="color:#8fbfdc;">do
</span><span>  </span><span style="color:#8fbfdc;">defp </span><span style="color:#fad07a;">line_stream_from_file</span><span>(path, chunk_size) </span><span style="color:#8fbfdc;">do
</span><span>    path
</span><span>    |&gt; </span><span style="color:#ffb964;">File</span><span>.stream!(chunk_size, </span><span style="color:#7697d6;">read_ahead:</span><span> chunk_size)
</span><span>    |&gt; bin_stream_to_line_stream()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">defp </span><span style="color:#fad07a;">bin_stream_to_line_stream</span><span>(bin_stream) </span><span style="color:#8fbfdc;">do
</span><span>    start_fn = </span><span style="color:#8fbfdc;">fn </span><span>-&gt; </span><span style="color:#556633;">&quot;&quot; </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>)
</span><span>
</span><span>    reducer_fn = </span><span style="color:#8fbfdc;">fn</span><span> chunk, acc -&gt;
</span><span>      [r | lines] =
</span><span>        (acc &lt;&gt; chunk)
</span><span>        |&gt; </span><span style="color:#ffb964;">String</span><span>.split(pattern)
</span><span>        |&gt; </span><span style="color:#ffb964;">Enum</span><span>.reverse()
</span><span>
</span><span>      {lines, r}
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    last_fn = </span><span style="color:#8fbfdc;">fn</span><span> acc -&gt;
</span><span>      {[acc], acc}
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    after_fn = </span><span style="color:#8fbfdc;">fn</span><span> acc -&gt;
</span><span>      acc
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    </span><span style="color:#ffb964;">Stream</span><span>.transform(bin_stream, start_fn, reducer_fn, last_fn, after_fn)
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">def </span><span style="color:#fad07a;">start_count</span><span>(fname) </span><span style="color:#8fbfdc;">do
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern(</span><span style="color:#556633;">&quot; &quot;</span><span>)
</span><span>    table = </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, [])
</span><span>    parent = self()
</span><span>
</span><span>    count_per_chunk = </span><span style="color:#8fbfdc;">fn</span><span> lines -&gt;
</span><span>      subtable = </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, [])
</span><span>
</span><span>      lines
</span><span>      |&gt; </span><span style="color:#ffb964;">Stream</span><span>.flat_map(&amp;</span><span style="color:#ffb964;">String</span><span>.split(</span><span style="color:#7697d6;">&amp;1</span><span>, pattern, </span><span style="color:#7697d6;">trim: </span><span>true))
</span><span>      |&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(&amp;</span><span style="color:#7697d6;">:ets</span><span>.update_counter(subtable, </span><span style="color:#7697d6;">&amp;1</span><span>, {</span><span style="color:#cf6a4c;">2</span><span>, </span><span style="color:#cf6a4c;">1</span><span>}, {</span><span style="color:#7697d6;">&amp;1</span><span>, </span><span style="color:#cf6a4c;">0</span><span>}))
</span><span>
</span><span>      </span><span style="color:#7697d6;">:ets</span><span>.give_away(subtable, parent, [])
</span><span>      subtable
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    {_, acc} =
</span><span>      line_stream_from_file(fname, </span><span style="color:#cf6a4c;">1_024_000</span><span>)
</span><span>      |&gt; </span><span style="color:#ffb964;">Stream</span><span>.chunk_every(</span><span style="color:#cf6a4c;">151_589</span><span>)
</span><span>      |&gt; </span><span style="color:#ffb964;">Task</span><span>.async_stream(count_per_chunk, </span><span style="color:#7697d6;">ordered: </span><span>false, </span><span style="color:#7697d6;">on_timeout: :exit</span><span>, </span><span style="color:#7697d6;">timeout: :infinity</span><span>)
</span><span style="color:#888888;">      # |&gt; Enum.flat_map(fn {:ok, subtable} -&gt;
</span><span style="color:#888888;">      #  :ets.tab2list(subtable)
</span><span style="color:#888888;">      # end)
</span><span style="color:#888888;">      # |&gt; Enum.reduce(table, fn {word, count}, acc -&gt;
</span><span style="color:#888888;">      #  :ets.update_counter(acc, word, {2, count}, {word, 0})
</span><span style="color:#888888;">      #  acc
</span><span style="color:#888888;">      # end)
</span><span>
</span><span>      |&gt; </span><span style="color:#ffb964;">Enum</span><span>.flat_map_reduce(table, </span><span style="color:#8fbfdc;">fn </span><span>{</span><span style="color:#7697d6;">:ok</span><span>, subtable}, acc -&gt;
</span><span>        </span><span style="color:#7697d6;">:ets</span><span>.tab2list(subtable)
</span><span>        |&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt; </span><span style="color:#7697d6;">:ets</span><span>.update_counter(acc, word, {</span><span style="color:#cf6a4c;">2</span><span>, count}, {word, </span><span style="color:#cf6a4c;">0</span><span>}) </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>
</span><span>        {[], acc}
</span><span>      </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>
</span><span>    acc
</span><span>    |&gt; </span><span style="color:#7697d6;">:ets</span><span>.tab2list()
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.sort(</span><span style="color:#8fbfdc;">fn </span><span>{_, a}, {_, b} -&gt; a &gt; b </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.map(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt;
</span><span>      [</span><span style="color:#ffb964;">Integer</span><span>.to_string(count), </span><span style="color:#556633;">&quot; &quot;</span><span>, word, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>]
</span><span>    </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">IO</span><span>.binwrite()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span style="color:#8fbfdc;">end
</span><span>
</span><span style="color:#ffb964;">System</span><span>.argv()
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.at(</span><span style="color:#cf6a4c;">0</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">./words-llvm8.0.txt</span><span style="color:#556633;">&quot;</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">WordFreq</span><span>.start_count()
</span></code></pre>
<p>之前代码是每个beam process 共享一个ets table 来采集统计结果, 现在是每个process 单独一个table， 然后在最后阶段，合并成一个table, bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: elixir wordfreq_chunkread_multiets.exs
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      3.310 s ±  0.045 s    </span><span style="color:#8fbfdc;">[</span><span>User: 14.493 s, System: 1.047 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    3.245 s …  3.404 s    10 runs
</span></code></pre>
<p>在粗略读了部分<a href="https://www.erlang.org/doc/apps/stdlib/ets.html#">erlang ets table 的文档</a>后， 发现有ordered_set 风格的ets table , 能不能使用ordered_set 排序,替换Enum.sort ?</p>
<p>wordfreq_chunkread_multiets_sort.exs:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span style="color:#8fbfdc;">defmodule </span><span style="color:#ffb964;">WordFreq </span><span style="color:#8fbfdc;">do
</span><span>  </span><span style="color:#8fbfdc;">defp </span><span style="color:#fad07a;">line_stream_from_file</span><span>(path, chunk_size) </span><span style="color:#8fbfdc;">do
</span><span>    path
</span><span>    |&gt; </span><span style="color:#ffb964;">File</span><span>.stream!(chunk_size, </span><span style="color:#7697d6;">read_ahead:</span><span> chunk_size)
</span><span>    |&gt; bin_stream_to_line_stream()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">defp </span><span style="color:#fad07a;">bin_stream_to_line_stream</span><span>(bin_stream) </span><span style="color:#8fbfdc;">do
</span><span>    start_fn = </span><span style="color:#8fbfdc;">fn </span><span>-&gt; </span><span style="color:#556633;">&quot;&quot; </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>)
</span><span>
</span><span>    reducer_fn = </span><span style="color:#8fbfdc;">fn</span><span> chunk, acc -&gt;
</span><span>      [r | lines] =
</span><span>        (acc &lt;&gt; chunk)
</span><span>        |&gt; </span><span style="color:#ffb964;">String</span><span>.split(pattern)
</span><span>        |&gt; </span><span style="color:#ffb964;">Enum</span><span>.reverse()
</span><span>
</span><span>      {lines, r}
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    last_fn = </span><span style="color:#8fbfdc;">fn</span><span> acc -&gt;
</span><span>      {[acc], acc}
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    after_fn = </span><span style="color:#8fbfdc;">fn</span><span> acc -&gt;
</span><span>      acc
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    </span><span style="color:#ffb964;">Stream</span><span>.transform(bin_stream, start_fn, reducer_fn, last_fn, after_fn)
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">def </span><span style="color:#fad07a;">start_count</span><span>(fname) </span><span style="color:#8fbfdc;">do
</span><span>    pattern = </span><span style="color:#7697d6;">:binary</span><span>.compile_pattern(</span><span style="color:#556633;">&quot; &quot;</span><span>)
</span><span>    table = </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, [])
</span><span>    parent = self()
</span><span>
</span><span>    count_per_chunk = </span><span style="color:#8fbfdc;">fn</span><span> lines -&gt;
</span><span>      subtable = </span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:words</span><span>, [])
</span><span>
</span><span>      lines
</span><span>      |&gt; </span><span style="color:#ffb964;">Stream</span><span>.flat_map(&amp;</span><span style="color:#ffb964;">String</span><span>.split(</span><span style="color:#7697d6;">&amp;1</span><span>, pattern, </span><span style="color:#7697d6;">trim: </span><span>true))
</span><span>      |&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(&amp;</span><span style="color:#7697d6;">:ets</span><span>.update_counter(subtable, </span><span style="color:#7697d6;">&amp;1</span><span>, {</span><span style="color:#cf6a4c;">2</span><span>, </span><span style="color:#cf6a4c;">1</span><span>}, {</span><span style="color:#7697d6;">&amp;1</span><span>, </span><span style="color:#cf6a4c;">0</span><span>}))
</span><span>
</span><span>      </span><span style="color:#7697d6;">:ets</span><span>.give_away(subtable, parent, [])
</span><span>      subtable
</span><span>    </span><span style="color:#8fbfdc;">end
</span><span>
</span><span>    {_, acc} =
</span><span>      line_stream_from_file(fname, </span><span style="color:#cf6a4c;">1_024_000</span><span>)
</span><span>      |&gt; </span><span style="color:#ffb964;">Stream</span><span>.chunk_every(</span><span style="color:#cf6a4c;">151_589</span><span>)
</span><span>      |&gt; </span><span style="color:#ffb964;">Task</span><span>.async_stream(count_per_chunk, </span><span style="color:#7697d6;">ordered: </span><span>false, </span><span style="color:#7697d6;">on_timeout: :exit</span><span>, </span><span style="color:#7697d6;">timeout: :infinity</span><span>)
</span><span>      |&gt; </span><span style="color:#ffb964;">Enum</span><span>.flat_map_reduce(table, </span><span style="color:#8fbfdc;">fn </span><span>{</span><span style="color:#7697d6;">:ok</span><span>, subtable}, acc -&gt;
</span><span>        </span><span style="color:#7697d6;">:ets</span><span>.tab2list(subtable)
</span><span>        |&gt; </span><span style="color:#ffb964;">Enum</span><span>.each(</span><span style="color:#8fbfdc;">fn </span><span>{word, count} -&gt; </span><span style="color:#7697d6;">:ets</span><span>.update_counter(acc, word, {</span><span style="color:#cf6a4c;">2</span><span>, count}, {word, </span><span style="color:#cf6a4c;">0</span><span>}) </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>
</span><span>        {[], acc}
</span><span>      </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>
</span><span>    acc
</span><span>    |&gt; </span><span style="color:#7697d6;">:ets</span><span>.tab2list()
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.group_by(</span><span style="color:#ffb964;">&amp;elem</span><span>(</span><span style="color:#7697d6;">&amp;1</span><span>, </span><span style="color:#cf6a4c;">1</span><span>), </span><span style="color:#ffb964;">&amp;elem</span><span>(</span><span style="color:#7697d6;">&amp;1</span><span>, </span><span style="color:#cf6a4c;">0</span><span>))
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.reduce(</span><span style="color:#7697d6;">:ets</span><span>.new(</span><span style="color:#7697d6;">:sort_arena</span><span>, [</span><span style="color:#7697d6;">:ordered_set</span><span>]), </span><span style="color:#8fbfdc;">fn </span><span>{count, wordlist}, acc -&gt;
</span><span>      </span><span style="color:#7697d6;">:ets</span><span>.update_element(acc, count, {</span><span style="color:#cf6a4c;">2</span><span>, wordlist}, {</span><span style="color:#cf6a4c;">0</span><span>, []})
</span><span>      acc
</span><span>    </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#7697d6;">:ets</span><span>.select_reverse([{{</span><span style="color:#7697d6;">:&quot;$1&quot;</span><span>, </span><span style="color:#7697d6;">:&quot;$2&quot;</span><span>}, [], [{{</span><span style="color:#7697d6;">:&quot;$1&quot;</span><span>, </span><span style="color:#7697d6;">:&quot;$2&quot;</span><span>}}]}])
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.map(</span><span style="color:#8fbfdc;">fn </span><span>{num, words} -&gt;
</span><span>      num_str = </span><span style="color:#ffb964;">Integer</span><span>.to_string(num)
</span><span>
</span><span>      </span><span style="color:#8fbfdc;">for</span><span> word &lt;- words </span><span style="color:#8fbfdc;">do
</span><span>        [num_str, </span><span style="color:#556633;">&quot; &quot;</span><span>, word, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>]
</span><span>      </span><span style="color:#8fbfdc;">end
</span><span>    </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>    |&gt; </span><span style="color:#ffb964;">IO</span><span>.binwrite()
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span style="color:#8fbfdc;">end
</span><span>
</span><span style="color:#ffb964;">System</span><span>.argv()
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.at(</span><span style="color:#cf6a4c;">0</span><span>, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">./words-llvm8.0.txt</span><span style="color:#556633;">&quot;</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">WordFreq</span><span>.start_count()
</span></code></pre>
<p>bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: elixir  wordfreq_chunkread_multiets_sort.exs
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      3.266 s ±  0.058 s    </span><span style="color:#8fbfdc;">[</span><span>User: 14.800 s, System: 1.027 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    3.187 s …  3.379 s    10 runs
</span></code></pre>
<p>稍微有点改进， 这段使用ordered_set 排序code，刚开始我是这样写的:</p>
<pre data-lang="elixir" style="background-color:#151515;color:#e8e8d3;" class="language-elixir "><code class="language-elixir" data-lang="elixir"><span>acc
</span><span>|&gt; </span><span style="color:#7697d6;">:ets</span><span>.tab2list()
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.reduce(sort_arena, </span><span style="color:#8fbfdc;">fn </span><span>{word, count}, acc -&gt;
</span><span>  word_list =
</span><span>    </span><span style="color:#7697d6;">:ets</span><span>.select(acc, [{{</span><span style="color:#7697d6;">:&quot;$1&quot;</span><span>, </span><span style="color:#7697d6;">:&quot;$2&quot;</span><span>}, [{</span><span style="color:#7697d6;">:==</span><span>, </span><span style="color:#7697d6;">:&quot;$1&quot;</span><span>, count}], [</span><span style="color:#7697d6;">:&quot;$2&quot;</span><span>]}])
</span><span>    |&gt; </span><span style="color:#ffb964;">Enum</span><span>.flat_map(</span><span style="color:#8fbfdc;">fn</span><span> e -&gt; e </span><span style="color:#8fbfdc;">end</span><span>)
</span><span>
</span><span>  </span><span style="color:#7697d6;">:ets</span><span>.update_element(acc, count, {</span><span style="color:#cf6a4c;">2</span><span>, [word | word_list]}, {</span><span style="color:#cf6a4c;">0</span><span>, []})
</span><span>  acc
</span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#7697d6;">:ets</span><span>.select_reverse([{{</span><span style="color:#7697d6;">:&quot;$1&quot;</span><span>, </span><span style="color:#7697d6;">:&quot;$2&quot;</span><span>}, [], [{{</span><span style="color:#7697d6;">:&quot;$1&quot;</span><span>, </span><span style="color:#7697d6;">:&quot;$2&quot;</span><span>}}]}])
</span><span>|&gt; </span><span style="color:#ffb964;">Enum</span><span>.map(</span><span style="color:#8fbfdc;">fn </span><span>{num, words} -&gt;
</span><span>  num_str = </span><span style="color:#ffb964;">Integer</span><span>.to_string(num)
</span><span>
</span><span>  </span><span style="color:#8fbfdc;">for</span><span> word &lt;- words </span><span style="color:#8fbfdc;">do
</span><span>    [num_str, </span><span style="color:#556633;">&quot; &quot;</span><span>, word, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&quot;</span><span>]
</span><span>  </span><span style="color:#8fbfdc;">end
</span><span style="color:#8fbfdc;">end</span><span>)
</span><span>|&gt; </span><span style="color:#ffb964;">IO</span><span>.binwrite()
</span></code></pre>
<p>测试之后，发现慢的惊人, 大概二十多分钟, 不知道为何， 直觉猜测是频繁地查询，更新table ，产生了大量临时copy ? ets doc 这样说:</p>
<blockquote>
<p>In the current implementation, every object insert and look-up operation results in a copy of the object.</p>
</blockquote>
<p>也许我该学习怎么使用cprof, eprof, fprof 或者 <a href="https://github.com/Stratus3D/eflambe">eflambe</a>.</p>
<p>PS  ets table 查询语法比较怪异，有些类似mongodb</p>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://unixisevil.github.io/atomic-order/">atomic-order</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-07-31
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/atomic/">#atomic</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/rust/">#rust</a></span>
    

                    
        <div class="post-content">
            <p><a href="https://doc.rust-lang.org/std/sync/atomic/index.html">目前rust atomic的rule大致使用C++20的rule</a>,  所以我感觉很多相关的东西是互通的， rust社区有Mara Bos 写的 <a href="https://marabos.nl/atomics/">Rust Atomics and Locks</a>,  C++社区有Anthony Williams 写的<a href="https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition">C++ Concurrency in Action</a>, 这两本书都是很好的学习资料.</p>
<p>首先看Relaxed ordering, 对于不同的atomic variable 读写，理论上不强制任何Order.
具体到不同的hardware memory model实现， 这个抽象的software model, relaxed ordering 有不同意思，  对于X86硬件来说, relaxed 意味着处理器会respect Program Order 中的  R || R ,  R || W,  W || W,    不会respect 处理器看见的 W || R .   对于Arm硬件来说,  只要读写指令中没有地址依赖，寄存器依赖， 处理器可以reorder 以上四种读写order组合.  <a href="https://www.youtube.com/watch?v=BciWwv9Z0kE">我发现这个讲解ARM memory model的视频很不错</a>.</p>
<p>Relaxed Ordering 给程序员唯一的保证是对于单个atomic variable 的Total modification order,
Anthony Williams 有个很形象的比喻, 想象一下，每个atomic variable是一个坐在封闭电话厅的人，手中有一个记事本，外面的人可以打电话与其通信， 他一次只能与一个人通信，你可以电话他，要求给你一个记事本中的数字，或者你告诉他一个数字，要求他在记事本后面追加上，  当你要求首次查询数字时，他可能从记事本中随机挑选一个告诉你， 不过这个号码记录员有个习惯， 每当有人向他查询数字，他会记录这次从哪个位置挑选的数字告诉客户， 如果有客户重复查询， 他会从上次告诉这位客户的位置和当前号码列表的尾部位置之间随机选择一个数字通知客户. 也就是说每个查询客户都可能观察的不是最新的数字(号码列表中尾部位置的数字), 但是客户对号码变化的观察历史不会倒退(也许客户可以观察到数字历史的倒退，因为可能存在数字的重复，但从号码记录员的角度看，这个变化历史是线型往前).</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::fmt;
</span><span>use std::sync::atomic::{
</span><span>    AtomicBool, AtomicUsize,
</span><span>    Ordering::{Acquire, Relaxed, Release},
</span><span>};
</span><span>
</span><span>use std::thread;
</span><span>
</span><span style="color:#8fbfdc;">static</span><span> X: AtomicUsize = AtomicUsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span style="color:#8fbfdc;">static</span><span> Y: AtomicUsize = AtomicUsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span style="color:#8fbfdc;">static</span><span> Z: AtomicUsize = AtomicUsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span style="color:#8fbfdc;">static </span><span style="color:#7697d6;">GO</span><span>: AtomicBool = AtomicBool::new(false);
</span><span>
</span><span style="color:#8fbfdc;">const </span><span style="color:#7697d6;">LOOP_COUNT</span><span>: </span><span style="color:#8fbfdc;">usize </span><span>= </span><span style="color:#cf6a4c;">10</span><span>;
</span><span>
</span><span>#[</span><span style="color:#ffb964;">derive</span><span>(Default, Copy, Clone)]
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">Sample </span><span>{
</span><span>    </span><span style="color:#ffb964;">x</span><span>: </span><span style="color:#8fbfdc;">usize</span><span>,
</span><span>    </span><span style="color:#ffb964;">y</span><span>: </span><span style="color:#8fbfdc;">usize</span><span>,
</span><span>    </span><span style="color:#ffb964;">z</span><span>: </span><span style="color:#8fbfdc;">usize</span><span>,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>fmt::Debug for </span><span style="color:#ffb964;">Sample </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">fmt</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">f</span><span>: &amp;</span><span style="color:#8fbfdc;">mut </span><span>fmt::Formatter&lt;&#39;_&gt;) -&gt; fmt::Result {
</span><span>        write!(f, </span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">(</span><span style="color:#7697d6;">{}</span><span style="color:#99ad6a;">, </span><span style="color:#7697d6;">{}</span><span style="color:#99ad6a;">, </span><span style="color:#7697d6;">{}</span><span style="color:#99ad6a;">)</span><span style="color:#556633;">&quot;</span><span>, </span><span style="color:#ffb964;">self</span><span>.x, </span><span style="color:#ffb964;">self</span><span>.y, </span><span style="color:#ffb964;">self</span><span>.z)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">increment</span><span>(</span><span style="color:#ffb964;">var</span><span>: &amp;AtomicUsize, </span><span style="color:#ffb964;">arr</span><span>: &amp;</span><span style="color:#8fbfdc;">mut</span><span> [Sample]) {
</span><span>    </span><span style="color:#8fbfdc;">while </span><span>!</span><span style="color:#7697d6;">GO</span><span>.load(Acquire) {
</span><span>        thread::yield_now();
</span><span>    }
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>(i, e) in arr.iter_mut().enumerate() {
</span><span>        e.x = X.load(Relaxed);
</span><span>        e.y = Y.load(Relaxed);
</span><span>        e.z = Z.load(Relaxed);
</span><span>        var.store(i + </span><span style="color:#cf6a4c;">1</span><span>, Relaxed);
</span><span>        thread::yield_now();
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">watch</span><span>(</span><span style="color:#ffb964;">arr</span><span>: &amp;</span><span style="color:#8fbfdc;">mut</span><span> [Sample]) {
</span><span>    </span><span style="color:#8fbfdc;">while </span><span>!</span><span style="color:#7697d6;">GO</span><span>.load(Acquire) {
</span><span>        thread::yield_now();
</span><span>    }
</span><span>    </span><span style="color:#8fbfdc;">for</span><span> e in arr.iter_mut() {
</span><span>        e.x = X.load(Relaxed);
</span><span>        e.y = Y.load(Relaxed);
</span><span>        e.z = Z.load(Relaxed);
</span><span>        thread::yield_now();
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> sample1: [Sample; </span><span style="color:#7697d6;">LOOP_COUNT</span><span>] = Default::default();
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> sample2 = sample1;
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> sample3 = sample1;
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> sample4 = sample1;
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> sample5 = sample1;
</span><span>
</span><span>    thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>        s.spawn(|| increment(&amp;X, &amp;</span><span style="color:#8fbfdc;">mut</span><span> sample1[..]));
</span><span>        s.spawn(|| increment(&amp;Y, &amp;</span><span style="color:#8fbfdc;">mut</span><span> sample2[..]));
</span><span>        s.spawn(|| increment(&amp;Z, &amp;</span><span style="color:#8fbfdc;">mut</span><span> sample3[..]));
</span><span>        s.spawn(|| watch(&amp;</span><span style="color:#8fbfdc;">mut</span><span> sample4[..]));
</span><span>        s.spawn(|| watch(&amp;</span><span style="color:#8fbfdc;">mut</span><span> sample5[..]));
</span><span>        </span><span style="color:#7697d6;">GO</span><span>.store(true, Release);
</span><span>    });
</span><span>
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">sample1: </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, sample1);
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">sample2: </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, sample2);
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">sample3: </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, sample3);
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">sample4: </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, sample4);
</span><span>    println!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">sample5: </span><span style="color:#7697d6;">{:?}</span><span style="color:#556633;">&quot;</span><span>, sample5);
</span><span>}
</span></code></pre>
<p>某次执行的输出:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">sample1: </span><span style="color:#8fbfdc;">[</span><span>(0, 0, 1), (1, 0, 2), (2, 0, 3), (3, 0, 4), (4, 0, 5), (5, 0, 6), (6, 0, 7), (7, 0, 8), (8, 0, 9), (9, 0, 10)</span><span style="color:#8fbfdc;">]
</span><span style="color:#ffb964;">sample2: </span><span style="color:#8fbfdc;">[</span><span>(10, 0, 10), (10, 1, 10), (10, 2, 10), (10, 3, 10), (10, 4, 10), (10, 5, 10), (10, 6, 10), (10, 7, 10), (10, 8, 10), (10, 9, 10)</span><span style="color:#8fbfdc;">]
</span><span style="color:#ffb964;">sample3: </span><span style="color:#8fbfdc;">[</span><span>(0, 0, 0), (1, 0, 1), (2, 0, 2), (3, 0, 3), (4, 0, 4), (5, 0, 5), (6, 0, 6), (7, 0, 7), (8, 0, 8), (9, 0, 9)</span><span style="color:#8fbfdc;">]
</span><span style="color:#ffb964;">sample4: </span><span style="color:#8fbfdc;">[</span><span>(10, 6, 10), (10, 8, 10), (10, 9, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10)</span><span style="color:#8fbfdc;">]
</span><span style="color:#ffb964;">sample5: </span><span style="color:#8fbfdc;">[</span><span>(10, 0, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10), (10, 10, 10)</span><span style="color:#8fbfdc;">]
</span></code></pre>
<p>三个incrementer线程各自单调自增X,Y,Z， 同时观察这三个atomic variable 的值， 其它两个纯观察者:
incrementer 能够即时观察到自己负责修改的变量， 对于其它两个变量不能保证即时观察到最新的值.</p>
<p>Relaxed ordering 不能保证下面关于z 的断言不会失败:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering::Relaxed};
</span><span>use std::thread;
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> x = AtomicBool::new(false);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> y = AtomicBool::new(false);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> z = AtomicUsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">write_x_then_y </span><span>= || {
</span><span>        x.store(true, Relaxed);
</span><span>        y.store(true, Relaxed);
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">read_y_then_x </span><span>= || {
</span><span>        </span><span style="color:#8fbfdc;">while </span><span>!y.load(Relaxed) {
</span><span>            std::hint::spin_loop()
</span><span>        }
</span><span>        </span><span style="color:#8fbfdc;">if</span><span> x.load(Relaxed) {
</span><span>            z.fetch_add(</span><span style="color:#cf6a4c;">1</span><span>, Relaxed);
</span><span>        }
</span><span>    };
</span><span>
</span><span>    thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>        s.spawn(write_x_then_y);
</span><span>        s.spawn(read_y_then_x);
</span><span>    });
</span><span>
</span><span>    assert!(z.load(Relaxed) != </span><span style="color:#cf6a4c;">0</span><span>);
</span><span>}
</span></code></pre>
<p>很多常用的并发原语背后都使用了Release-Acquire ordering, 比如Mutex, Channel 等， Release ordering 使得处理器, 编译器respect Program order 中的  RW || W  ,   Acquire ordering 使得它们respect program order 中的  R || RW.   Release-Acquire 给并发实体之间引入了<a href="https://en.wikipedia.org/wiki/Partially_ordered_set">Partial Order</a>.  这种partial order 不能保证以下代码关于z 的断言不会失败:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::thread;
</span><span>use std::sync::atomic::{
</span><span>    AtomicBool, AtomicIsize, 
</span><span>    Ordering::{Release, Acquire, Relaxed},
</span><span>};
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>     </span><span style="color:#8fbfdc;">let</span><span> x = AtomicBool::new(false);
</span><span>     </span><span style="color:#8fbfdc;">let</span><span> y = AtomicBool::new(false);
</span><span>     </span><span style="color:#8fbfdc;">let</span><span> z = AtomicIsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">write_x  </span><span>= ||  x.store(true, Release);
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">write_y  </span><span>= ||  y.store(true, Release);
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">read_x_then_y  </span><span>= ||  {
</span><span>         </span><span style="color:#8fbfdc;">while </span><span>!x.load(Acquire) { std::hint::spin_loop() }
</span><span>         </span><span style="color:#8fbfdc;">if</span><span> y.load(Acquire) {
</span><span>             z.fetch_add(</span><span style="color:#cf6a4c;">1</span><span>, Relaxed);
</span><span>         }
</span><span>     };
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">read_y_then_x  </span><span>= ||  {
</span><span>         </span><span style="color:#8fbfdc;">while </span><span>!y.load(Acquire) { std::hint::spin_loop()  }
</span><span>         </span><span style="color:#8fbfdc;">if</span><span> x.load(Acquire) {
</span><span>             z.fetch_add(</span><span style="color:#cf6a4c;">1</span><span>, Relaxed);
</span><span>         }
</span><span>     };
</span><span>
</span><span>     thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>         s.spawn(write_x);
</span><span>         s.spawn(write_y);
</span><span>         s.spawn(read_x_then_y);
</span><span>         s.spawn(read_y_then_x);
</span><span>     });
</span><span>
</span><span>     assert!(z.load(Relaxed) != </span><span style="color:#cf6a4c;">0</span><span>);
</span><span>}
</span></code></pre>
<p>如果用上面困在电话厅中号码记录员例子做类比，这段代码相当于有三个记录员分别叫x, y, z,  还有四个客户叫write_x , write_y,  read_x_then_y,  read_y_then_x.  客户write_x 的行为是电话z 请求其在列表上追加true,  客户write_y 电话y, 行为类似.   客户read_x_then_y 不厌其烦地电话x直到x 给出true 为止， 然后去电话y;  客户read_y_than_x 行为类似，反向操作. 初始x, y 手中的列表只有false,
read_x_then_y 一直等到了x 手中的列表是[false, true], 然后电话y，此时y 手中的列表可能是[false] , 或者[false, true],  根据以前的规则， 无论是哪种情况，y 都可以从列表中随机选择一个回应， 也就是y的回应可能是false,  对称情形， read_y_then_x 从x 处得到的回应可能是false. 最终可能是read_x_than_y 从 x 收到true, 从y收到false,  “查询z的最新值并自增后追加" 操作没有发生, read_y_than_x 从 y 收到true, 从x收到false, “查询z的最新值并自增后追加" 操作没有发生, z 保持原来的值0.</p>
<p>Release-Acquire ordering 的好处是为non-atomic 操作和atomic 操作 确立order:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::thread;
</span><span>use std::sync::atomic::{
</span><span>    AtomicBool, AtomicIsize, 
</span><span>    Ordering::{
</span><span>        Relaxed,
</span><span>        Release,
</span><span>        Acquire,
</span><span>    },
</span><span>};
</span><span>
</span><span style="color:#8fbfdc;">static mut</span><span> X: </span><span style="color:#8fbfdc;">bool  </span><span>= false;
</span><span style="color:#8fbfdc;">static</span><span> Y: AtomicBool = AtomicBool::new(false);
</span><span style="color:#8fbfdc;">static</span><span> Z: AtomicIsize = AtomicIsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">write_x_then_y </span><span>= || {
</span><span>         </span><span style="color:#8fbfdc;">unsafe </span><span>{ X = true };
</span><span>         Y.store(true, Release);
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">read_y_then_x  </span><span>= ||  {
</span><span>         </span><span style="color:#8fbfdc;">while </span><span>!Y.load(Acquire) { std::hint::spin_loop()  }
</span><span>         </span><span style="color:#8fbfdc;">if unsafe </span><span>{ X } {
</span><span>             Z.fetch_add(</span><span style="color:#cf6a4c;">1</span><span>, Relaxed);
</span><span>         }
</span><span>     };
</span><span>
</span><span>     thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>         s.spawn(write_x_then_y);
</span><span>         s.spawn(read_y_then_x);
</span><span>     });
</span><span>
</span><span>     assert!(Z.load(Relaxed) != </span><span style="color:#cf6a4c;">0</span><span>);
</span><span>}
</span></code></pre>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::sync::atomic::{
</span><span>    AtomicBool, AtomicUsize,
</span><span>    Ordering::{Acquire, Relaxed, Release},
</span><span>};
</span><span>use std::thread;
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> x = AtomicBool::new(false);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> y = AtomicBool::new(false);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> z = AtomicUsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">write_x_then_y </span><span>= || {
</span><span>        x.store(true, Relaxed);
</span><span>        y.store(true, Release);
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">read_y_then_x </span><span>= || {
</span><span>        </span><span style="color:#8fbfdc;">while </span><span>!y.load(Acquire) {
</span><span>            std::hint::spin_loop()
</span><span>        }
</span><span>        </span><span style="color:#8fbfdc;">if</span><span> x.load(Relaxed) {
</span><span>            z.fetch_add(</span><span style="color:#cf6a4c;">1</span><span>, Relaxed);
</span><span>        }
</span><span>    };
</span><span>
</span><span>    thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>        s.spawn(write_x_then_y);
</span><span>        s.spawn(read_y_then_x);
</span><span>    });
</span><span>
</span><span>    assert!(z.load(Relaxed) != </span><span style="color:#cf6a4c;">0</span><span>);
</span><span>}
</span></code></pre>
<p>这两段代码中关于z 的断言不会失败</p>
<p>Release-Acqire ordering  具有传递性:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::sync::atomic::{
</span><span>    AtomicIsize,
</span><span>    Ordering::{AcqRel, Acquire, Relaxed, Release},
</span><span>};
</span><span>
</span><span>use std::thread;
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> arr = [</span><span style="color:#8fbfdc;">const </span><span>{ AtomicIsize::new(</span><span style="color:#cf6a4c;">0</span><span>) }; </span><span style="color:#cf6a4c;">5</span><span>];
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> sync = AtomicIsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">t1 </span><span>= || {
</span><span>        arr[</span><span style="color:#cf6a4c;">0</span><span>].store(</span><span style="color:#cf6a4c;">5</span><span>, Relaxed);
</span><span>        arr[</span><span style="color:#cf6a4c;">1</span><span>].store(</span><span style="color:#cf6a4c;">18</span><span>, Relaxed);
</span><span>        arr[</span><span style="color:#cf6a4c;">2</span><span>].store(</span><span style="color:#cf6a4c;">7</span><span>, Relaxed);
</span><span>        arr[</span><span style="color:#cf6a4c;">3</span><span>].store(-</span><span style="color:#cf6a4c;">29</span><span>, Relaxed);
</span><span>        arr[</span><span style="color:#cf6a4c;">4</span><span>].store(</span><span style="color:#cf6a4c;">2024</span><span>, Relaxed);
</span><span>        sync.store(</span><span style="color:#cf6a4c;">1</span><span>, Release);
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">t2 </span><span>= || {
</span><span>        </span><span style="color:#8fbfdc;">while</span><span> sync.compare_exchange(</span><span style="color:#cf6a4c;">1</span><span>, </span><span style="color:#cf6a4c;">2</span><span>, AcqRel, Relaxed).is_err() {
</span><span>            std::hint::spin_loop()
</span><span>        }
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">t3 </span><span>= || {
</span><span>        </span><span style="color:#8fbfdc;">while</span><span> sync.load(Acquire) &lt; </span><span style="color:#cf6a4c;">2 </span><span>{
</span><span>            std::hint::spin_loop()
</span><span>        }
</span><span>        assert!(arr[</span><span style="color:#cf6a4c;">0</span><span>].load(Relaxed) == </span><span style="color:#cf6a4c;">5</span><span>);
</span><span>        assert!(arr[</span><span style="color:#cf6a4c;">1</span><span>].load(Relaxed) == </span><span style="color:#cf6a4c;">18</span><span>);
</span><span>        assert!(arr[</span><span style="color:#cf6a4c;">2</span><span>].load(Relaxed) == </span><span style="color:#cf6a4c;">7</span><span>);
</span><span>        assert!(arr[</span><span style="color:#cf6a4c;">3</span><span>].load(Relaxed) == -</span><span style="color:#cf6a4c;">29</span><span>);
</span><span>        assert!(arr[</span><span style="color:#cf6a4c;">4</span><span>].load(Relaxed) == </span><span style="color:#cf6a4c;">2024</span><span>);
</span><span>    };
</span><span>
</span><span>    thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>        s.spawn(t1);
</span><span>        s.spawn(t2);
</span><span>        s.spawn(t3);
</span><span>    });
</span><span>}
</span></code></pre>
<p>如果某个包含Release 语义的原子操作， 后面跟随对同一个atomic variable 的一连串的 atomic RMW(read-modify-write) 操作, 可以形成所谓的Release Sequence.  我感觉Mara Bos在 <a href="https://marabos.nl/atomics/memory-ordering.html#release-and-acquire-ordering">More Formally Section</a> 解释的很好. 以下是一个Release Sequence 建立happens-before 关系的例子:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::cell::UnsafeCell;
</span><span>use std::sync::atomic::{
</span><span>    AtomicIsize,
</span><span>    Ordering::{Acquire, Release},
</span><span>};
</span><span>use std::thread;
</span><span>
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">Queue </span><span>{
</span><span>    </span><span style="color:#ffb964;">count</span><span>: AtomicIsize,
</span><span>    </span><span style="color:#ffb964;">q</span><span>: UnsafeCell&lt;Vec&lt;</span><span style="color:#8fbfdc;">isize</span><span>&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">unsafe impl </span><span>Sync for </span><span style="color:#ffb964;">Queue </span><span>{}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span style="color:#ffb964;">Queue </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">new</span><span>() -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>            count: AtomicIsize::new(</span><span style="color:#cf6a4c;">0</span><span>),
</span><span>            q: UnsafeCell::new(Vec::&lt;</span><span style="color:#8fbfdc;">isize</span><span>&gt;::new()),
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">populate</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>) {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> num_of_items: </span><span style="color:#8fbfdc;">isize </span><span>= </span><span style="color:#cf6a4c;">20</span><span>;
</span><span>        </span><span style="color:#8fbfdc;">for</span><span> i in </span><span style="color:#cf6a4c;">0</span><span>..num_of_items {
</span><span>            </span><span style="color:#8fbfdc;">unsafe </span><span>{ (*</span><span style="color:#ffb964;">self</span><span>.q.get()).push(i) };
</span><span>        }
</span><span>        </span><span style="color:#ffb964;">self</span><span>.count.store(num_of_items, Release);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">consume</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">id</span><span>: </span><span style="color:#8fbfdc;">usize</span><span>) {
</span><span>        </span><span style="color:#8fbfdc;">let mut</span><span> data_touch = false;
</span><span>        </span><span style="color:#8fbfdc;">let mut</span><span> woken = false;
</span><span>        </span><span style="color:#8fbfdc;">loop </span><span>{
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> remain = </span><span style="color:#ffb964;">self</span><span>.count.fetch_sub(</span><span style="color:#cf6a4c;">1</span><span>, Acquire);
</span><span>            </span><span style="color:#8fbfdc;">if</span><span> remain &lt;= </span><span style="color:#cf6a4c;">0 </span><span>{
</span><span>                </span><span style="color:#8fbfdc;">if </span><span>!data_touch &amp;&amp; !woken {
</span><span>                    std::thread::park();
</span><span>                    woken = true;
</span><span>                    </span><span style="color:#8fbfdc;">continue</span><span>;
</span><span>                } </span><span style="color:#8fbfdc;">else </span><span>{
</span><span>                    </span><span style="color:#8fbfdc;">break</span><span>;
</span><span>                }
</span><span>            }
</span><span>            println!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">c</span><span style="color:#7697d6;">{}</span><span style="color:#99ad6a;"> got item: </span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, id, </span><span style="color:#8fbfdc;">unsafe </span><span>{
</span><span>                (&amp;*</span><span style="color:#ffb964;">self</span><span>.q.get())[remain as </span><span style="color:#8fbfdc;">usize </span><span>- </span><span style="color:#cf6a4c;">1</span><span>]
</span><span>            });
</span><span>            data_touch = true;
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> q = Queue::new();
</span><span>    thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> c1 = s.spawn(|| q.consume(</span><span style="color:#cf6a4c;">1</span><span>));
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> c2 = s.spawn(|| q.consume(</span><span style="color:#cf6a4c;">2</span><span>));
</span><span>        q.populate();
</span><span>        c1.thread().unpark();
</span><span>        c2.thread().unpark();
</span><span>    });
</span><span>}
</span></code></pre>
<p>这个Release-Seqence有对count 的release store 和后面的对count 的fetch_sub 构成,  确保了填充队列完成 happens-before 两个队列数据消费者开始使用数据,  同时两个队列消费者之间没有建立order.</p>
<p>Release-Acquire 存在一个特别case， Release-Consume,  是希望能弱化Acquire 端对Order的强制， 在program order 中排在Acquire atomic operation 或者Acquire fence 后面的所有操作都不能reorder 到 Acquire 之前， 人们觉得杀伤范围过大, 能不能把order约束只限制在“相关依赖数据" 上， 其它无关语句仍然可以被编译器和处理器重排， 来获得更好的性能. <a href="https://www.youtube.com/watch?v=ZrNQKpOypqU&amp;t=1803s">尤其是像Paul McKenney等一些专家比较关心这些</a>, 可能是这个概念不好精确定义，编译器开发者很难实现它， <a href="https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Consume_ordering">自从C++ 17以来， Release-Consume不在被推荐</a>.</p>
<p>Rust当前也没有引入Consume Ordering, 不过看起来<a href="https://docs.rs/crossbeam-utils/latest/src/crossbeam_utils/atomic/consume.rs.html#34-48">crossbeam当前在ARM平台上使用Release Ordering + 一个Acquire语义的compiler_fence 来模拟</a>, 使用crossbeam 的consume  demo:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#![</span><span style="color:#ffb964;">feature</span><span>(new_uninit)]
</span><span>
</span><span>use crossbeam_utils::atomic::AtomicConsume;
</span><span>use std::ptr::addr_of_mut;
</span><span>use std::sync::atomic::{
</span><span>    AtomicIsize, AtomicPtr,
</span><span>    Ordering::{Relaxed, Release},
</span><span>};
</span><span>use std::{thread, time::Duration};
</span><span>
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">SomeStruct </span><span>{
</span><span>    </span><span style="color:#ffb964;">i</span><span>: </span><span style="color:#8fbfdc;">isize</span><span>,
</span><span>    </span><span style="color:#ffb964;">s</span><span>: String,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> p = AtomicPtr::new(std::ptr::null_mut());
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> a = AtomicIsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">init_some_struct </span><span>= || {
</span><span>        </span><span style="color:#8fbfdc;">let mut</span><span> uninit = Box::&lt;SomeStruct&gt;::new_uninit();
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> ss = {
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> pss = uninit.as_mut_ptr();
</span><span>            </span><span style="color:#8fbfdc;">unsafe </span><span>{
</span><span>                addr_of_mut!((*pss).i).write(</span><span style="color:#cf6a4c;">42</span><span>);
</span><span>                addr_of_mut!((*pss).s).write(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>.to_string());
</span><span>                uninit.assume_init()
</span><span>            }
</span><span>        };
</span><span>        a.store(</span><span style="color:#cf6a4c;">100</span><span>, Relaxed);
</span><span>        p.store(Box::into_raw(ss), Release);
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">use_some_struct </span><span>= || {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> pss = </span><span style="color:#8fbfdc;">loop </span><span>{
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> pss = p.load_consume();
</span><span>            </span><span style="color:#8fbfdc;">if </span><span>!pss.is_null() {
</span><span>                </span><span style="color:#8fbfdc;">break</span><span> pss;
</span><span>            }
</span><span>            thread::sleep(Duration::from_micros(</span><span style="color:#cf6a4c;">1</span><span>));
</span><span>        };
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> ss = </span><span style="color:#8fbfdc;">unsafe </span><span>{ Box::from_raw(pss) };
</span><span>        </span><span style="color:#888888;">//dbg!(ss.i);
</span><span>        </span><span style="color:#888888;">//dbg!(ss.s);
</span><span>        assert!(ss.s == *</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">Hi</span><span style="color:#556633;">&quot;</span><span>);
</span><span>        assert!(ss.i == </span><span style="color:#cf6a4c;">42</span><span>);
</span><span>        assert!(a.load(Relaxed) == </span><span style="color:#cf6a4c;">100</span><span>);
</span><span>    };
</span><span>
</span><span>    thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>        s.spawn(init_some_struct);
</span><span>        s.spawn(use_some_struct);
</span><span>    });
</span><span>}
</span></code></pre>
<p>Release-Consume Ordering 保证use_some_struct 线程观察到SomeStruct被合适地初始化了，仅此而已， 不能保证atomic variable a 的断言不会失败, 尤其是在weakly ordered machine 上，即使是ARM这种宣称weakly order 架构上， 不同的处理器厂商实现处理器时可能又做了order 的强化.</p>
<p>SeqCst 是对Order 保证最强的model， 但也可能是对性能伤害最大的， 尤其是在weakly order 的机器上，给予程序  RW || RW 的ordering 保证, 甚至X86处理器都没实现SeqCst.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::thread;
</span><span>use std::sync::atomic::{AtomicBool, AtomicIsize, Ordering::SeqCst};
</span><span>
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() {
</span><span>     </span><span style="color:#8fbfdc;">let</span><span> x = AtomicBool::new(false);
</span><span>     </span><span style="color:#8fbfdc;">let</span><span> y = AtomicBool::new(false);
</span><span>     </span><span style="color:#8fbfdc;">let</span><span> z = AtomicIsize::new(</span><span style="color:#cf6a4c;">0</span><span>);
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">write_x  </span><span>= ||  x.store(true, SeqCst);
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">write_y  </span><span>= ||  y.store(true, SeqCst);
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">read_x_then_y  </span><span>= ||  {
</span><span>         </span><span style="color:#8fbfdc;">while </span><span>!x.load(SeqCst) { std::hint::spin_loop() }
</span><span>         </span><span style="color:#8fbfdc;">if</span><span> y.load(SeqCst) {
</span><span>             z.fetch_add(</span><span style="color:#cf6a4c;">1</span><span>, SeqCst);
</span><span>         }
</span><span>     };
</span><span>
</span><span>     </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">read_y_then_x  </span><span>= ||  {
</span><span>         </span><span style="color:#8fbfdc;">while </span><span>!y.load(SeqCst) { std::hint::spin_loop()  }
</span><span>         </span><span style="color:#8fbfdc;">if</span><span> x.load(SeqCst) {
</span><span>             z.fetch_add(</span><span style="color:#cf6a4c;">1</span><span>, SeqCst);
</span><span>         }
</span><span>     };
</span><span>
</span><span>     thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>         s.spawn(write_x);
</span><span>         s.spawn(write_y);
</span><span>         s.spawn(read_x_then_y);
</span><span>         s.spawn(read_y_then_x);
</span><span>     });
</span><span>
</span><span>     assert!(z.load(SeqCst) != </span><span style="color:#cf6a4c;">0</span><span>);
</span><span>}
</span></code></pre>
<p>由于SeqCst 要求所有并发实体观察到的World View 必须一致, 断言不会失败.
SeqCst 的model 要求所有SeqCst 语义的操作形成一个全局的order，这种global order 仿佛是在保持每个线程的program order 的前提下， 任意交错合并而成的order.</p>

        </div>

                </div>
            <div class="pagination">
                <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://unixisevil.github.io/page/2/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Newer posts</span>
                        </a>
                    </span>
                
                    <span class="button next">
                        <a href="https://unixisevil.github.io/page/4/">
                            <span class="button__text">Older posts</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
            </div>
        </div>
        
    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
