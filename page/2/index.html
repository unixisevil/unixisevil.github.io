<!DOCTYPE html>
<html lang="en">

<head>
    <title>Random Notes</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://unixisevil.github.io/style.css">
    <link rel="stylesheet" href="https://unixisevil.github.io/color/blue.css">

    <link rel="stylesheet" href="https://unixisevil.github.io/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    <header class="header">
        <div class="header__inner">
            <div class="header__logo">
                    
                <a href="https://unixisevil.github.io" style="text-decoration: none;">
                    <div class="logo">
                      
                            Random Notes
                        
                    </div>
                </a>
            </div>
        </div>

        
        
                <nav class="menu">
            <ul class="menu__inner">
                <li><a href="https://unixisevil.github.io">blog</a></li>
            
                <li><a href="https://unixisevil.github.io/tags">tags</a></li>
            
                <li><a href="https://unixisevil.github.io/archive">archive</a></li>
            
                <li><a href="https://my.oschina.net/evilunix">old blog</a></li>
            
                <li class="active"><a href="https://unixisevil.github.io/" target="_blank" rel="noopener noreferrer">github</a></li>
            </ul>
        </nav>
    
    
        
    </header>
    

    <div class="content">
        
        <div class="posts">
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://unixisevil.github.io/semigroup-monoid/">semigroup and monoid in rust</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2025-02-14
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/monoid/">#monoid</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/rust/">#rust</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/semigroup/">#semigroup</a></span>
    

                    
        <div class="post-content">
            <p>前段时间看了看Haskell, 作为纯函数式编程语言, Haskell的根基几乎是用数学概念来构建, 比如<a href="https://en.wikipedia.org/wiki/Semigroup">Semigroup</a>, <a href="https://en.wikipedia.org/wiki/Monoid">Monoid</a>, 从这些数学定义看，这些概念有些抽象，不过从代码角度看，还是不难理解的.</p>
<p>Semigroup 和 Monoid 在Haskell 中被定义为type class(描述一类type 应该具备的行为, 类似rust的trait):</p>
<pre data-lang="haskell" style="background-color:#151515;color:#e8e8d3;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>class </span><span style="color:#ffb964;">Semigroup a </span><span>where
</span><span>  </span><span style="color:#fad07a;">(&lt;&gt;) </span><span>:: </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a
</span><span>
</span><span>class </span><span style="color:#ffb964;">Semigroup a</span><span> =&gt; </span><span style="color:#ffb964;">Monoid a </span><span>where
</span><span>  </span><span style="color:#fad07a;">mempty </span><span>:: </span><span style="color:#ffb964;">a
</span><span>  </span><span style="color:#fad07a;">mappend </span><span>:: </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a </span><span>-&gt; </span><span style="color:#ffb964;">a
</span><span>  </span><span style="color:#fad07a;">mconcat </span><span>:: [</span><span style="color:#ffb964;">a</span><span>] -&gt; </span><span style="color:#ffb964;">a
</span></code></pre>
<p>Semigroup 的核心行为是combine 运算符 (&lt;&gt;) :: Semigroup a =&gt; a -&gt; a -&gt; a,  combine 是二元运算, 其接收两个同类型的东西, 输出同样的东西, 只要是符合结合律的二元操作都是合法的combine 实现.  比如Integer 的 + 运算:</p>
<pre data-lang="haskell" style="background-color:#151515;color:#e8e8d3;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>instance </span><span style="color:#8fbfdc;">Semigroup Integer </span><span>where
</span><span>    </span><span style="color:#fad07a;">(&lt;&gt;)</span><span> x y = x + y
</span></code></pre>
<p>Monoid 是Semigroup 的拓展或者说是子类,  Monoid 具备combine 行为,  加上另一条行为要求: 实现Monoid 的type必须定义其identity 元素.
identity 元素的意思是 x &lt;&gt; id = x ,  id &lt;&gt; x  = x ,  任何x 与 identity 以任何order 的组合，结果都是返回x. 比如加法运算中的0，x + 0= 0 + x = 0,  乘法运算中的1, x * 1 = 1 * x =  x.</p>
<p>据说是历史原因，Monoid 先于 Semigroup 在标准库中被实现， 本来可以更简洁地被定义成:</p>
<pre data-lang="haskell" style="background-color:#151515;color:#e8e8d3;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>class </span><span style="color:#ffb964;">Semigroup a</span><span> =&gt; </span><span style="color:#ffb964;">Monoid a </span><span>where
</span><span>    </span><span style="color:#fad07a;">identity </span><span>:: </span><span style="color:#ffb964;">a
</span></code></pre>
<p>rust库<a href="https://crates.io/crates/frunk">frunk</a> 定义了Semigroup trait 和 Monoid trait. 以下是一些Semigroup 和 Monoid 的代码例子.</p>
<p>比如可以定义颜色是Semigroup 的实现:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#ffb964;">derive</span><span>(Debug, PartialEq, Eq, Copy, Clone)]
</span><span style="color:#8fbfdc;">enum </span><span style="color:#ffb964;">Color </span><span>{
</span><span>    Red,
</span><span>    Yellow,
</span><span>    Blue,
</span><span>    Green,
</span><span>    Purple,
</span><span>    Orange,
</span><span>    Brown,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Semigroup for </span><span style="color:#ffb964;">Color </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">other</span><span>: &amp;</span><span style="color:#8fbfdc;">Self</span><span>) -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">match </span><span>(</span><span style="color:#ffb964;">self</span><span>, other) {
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Blue) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Purple,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Red) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Purple,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Blue) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Green,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Green,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Red) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Orange,
</span><span>            (</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow) =&gt; </span><span style="color:#8fbfdc;">Self</span><span>::Orange,
</span><span>            (a, b) </span><span style="color:#8fbfdc;">if</span><span> a == b =&gt; *a,
</span><span>            (a, b) =&gt; {
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> rbp = [</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Purple];
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> byg = [</span><span style="color:#8fbfdc;">Self</span><span>::Blue, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Green];
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> ryo = [</span><span style="color:#8fbfdc;">Self</span><span>::Red, </span><span style="color:#8fbfdc;">Self</span><span>::Yellow, </span><span style="color:#8fbfdc;">Self</span><span>::Orange];
</span><span>                </span><span style="color:#8fbfdc;">if</span><span> rbp.contains(a) &amp;&amp; rbp.contains(b) {
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Purple
</span><span>                } </span><span style="color:#8fbfdc;">else if</span><span> byg.contains(a) &amp;&amp; byg.contains(b) {
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Green
</span><span>                } </span><span style="color:#8fbfdc;">else if</span><span> ryo.contains(a) &amp;&amp; ryo.contains(b) {
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Orange
</span><span>                } </span><span style="color:#8fbfdc;">else </span><span>{
</span><span>                    </span><span style="color:#8fbfdc;">Self</span><span>::Brown
</span><span>                }
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>Color 类型的combine 实现中，定义不同的颜色如何混合形成另一种颜色.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">Events </span><span>= Vec&lt;String&gt;;
</span><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">Probs </span><span>= Vec&lt;</span><span style="color:#8fbfdc;">f64</span><span>&gt;;
</span><span>
</span><span>#[</span><span style="color:#ffb964;">derive</span><span>(Clone)]
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">Ptable </span><span>{
</span><span>    </span><span style="color:#ffb964;">events</span><span>: Events,
</span><span>    </span><span style="color:#ffb964;">probs</span><span>: Probs,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Semigroup for </span><span style="color:#ffb964;">Ptable </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">other</span><span>: &amp;</span><span style="color:#8fbfdc;">Self</span><span>) -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">match </span><span>(</span><span style="color:#ffb964;">self</span><span>, other) {
</span><span>            (a, Ptable { events, probs }) </span><span style="color:#8fbfdc;">if</span><span> events.is_empty() &amp;&amp; probs.is_empty() =&gt; a.clone(),
</span><span>            (Ptable { events, probs }, b) </span><span style="color:#8fbfdc;">if</span><span> events.is_empty() &amp;&amp; probs.is_empty() =&gt; b.clone(),
</span><span>            (
</span><span>                Ptable {
</span><span>                    events: ea,
</span><span>                    probs: pa,
</span><span>                },
</span><span>                Ptable {
</span><span>                    events: eb,
</span><span>                    probs: pb,
</span><span>                },
</span><span>            ) =&gt; {
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> em = combine_events(ea, eb);
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> pm = combine_probs(pa, pb);
</span><span>                Ptable::new(em, pm)
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Monoid for </span><span style="color:#ffb964;">Ptable </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">empty</span><span>() -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        Ptable::new(vec![], vec![])
</span><span>    }
</span><span>}
</span></code></pre>
<p>事件发生的概率可以是Monoid，A 事件发生的概率是多少， B 事件的概率是多少， A 与 B 组合发生的概率是多少， 比如硬币连抛三次的事件的概率是多少.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#ffb964;">derive</span><span>(Clone)]
</span><span style="color:#8fbfdc;">struct </span><span style="color:#ffb964;">TimeSeries </span><span>{
</span><span>    </span><span style="color:#ffb964;">ts</span><span>: Vec&lt;</span><span style="color:#8fbfdc;">i32</span><span>&gt;,
</span><span>    </span><span style="color:#ffb964;">vs</span><span>: Vec&lt;Option&lt;</span><span style="color:#8fbfdc;">f64</span><span>&gt;&gt;,
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine_time_series</span><span>(</span><span style="color:#ffb964;">a</span><span>: &amp;TimeSeries, </span><span style="color:#ffb964;">b</span><span>: &amp;TimeSeries) -&gt; TimeSeries {
</span><span>    </span><span style="color:#8fbfdc;">match </span><span>(a, b) {
</span><span>        (TimeSeries { ts, vs }, b) </span><span style="color:#8fbfdc;">if</span><span> ts.is_empty() &amp;&amp; vs.is_empty() =&gt; b.clone(),
</span><span>        (a, TimeSeries { ts, vs }) </span><span style="color:#8fbfdc;">if</span><span> ts.is_empty() &amp;&amp; vs.is_empty() =&gt; a.clone(),
</span><span>        (TimeSeries { ts: t1, vs: v1 }, TimeSeries { ts: t2, vs: v2 }) =&gt; {
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> mt = t1.iter().chain(t2);
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> min = mt.clone().min().copied().unwrap();
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> max = mt.max().unwrap();
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> complete_times = min..max + </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>            </span><span style="color:#8fbfdc;">let mut</span><span> acc = BTreeMap::&lt;</span><span style="color:#8fbfdc;">i32</span><span>, </span><span style="color:#8fbfdc;">f64</span><span>&gt;::default();
</span><span>
</span><span>            </span><span style="color:#8fbfdc;">let </span><span style="color:#fad07a;">insert_tv_pair </span><span>= |</span><span style="color:#ffb964;">map</span><span>: &amp;</span><span style="color:#8fbfdc;">mut </span><span>BTreeMap&lt;_, _&gt;, </span><span style="color:#ffb964;">tv_pair</span><span>: (&amp;_, &amp;_)| </span><span style="color:#8fbfdc;">match</span><span> tv_pair {
</span><span>                (_, None) =&gt; {}
</span><span>                (t, Some(v)) =&gt; {
</span><span>                    map.insert(*t, *v);
</span><span>                }
</span><span>            };
</span><span>            </span><span style="color:#8fbfdc;">let mut</span><span> acc = t1.iter().zip(v1.iter()).fold(&amp;</span><span style="color:#8fbfdc;">mut</span><span> acc, |</span><span style="color:#ffb964;">acc</span><span>, </span><span style="color:#ffb964;">e</span><span>| {
</span><span>                insert_tv_pair(acc, e);
</span><span>                acc
</span><span>            });
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> acc = t2.iter().zip(v2.iter()).fold(&amp;</span><span style="color:#8fbfdc;">mut</span><span> acc, |</span><span style="color:#ffb964;">acc</span><span>, </span><span style="color:#ffb964;">e</span><span>| {
</span><span>                insert_tv_pair(acc, e);
</span><span>                acc
</span><span>            });
</span><span>            </span><span style="color:#8fbfdc;">let</span><span> final_vs: Vec&lt;Option&lt;</span><span style="color:#8fbfdc;">f64</span><span>&gt;&gt; = complete_times
</span><span>                .clone()
</span><span>                .map(|</span><span style="color:#ffb964;">t</span><span>| acc.get(&amp;t).copied())
</span><span>                .collect();
</span><span>
</span><span>            TimeSeries {
</span><span>                ts: complete_times.collect::&lt;Vec&lt;</span><span style="color:#8fbfdc;">i32</span><span>&gt;&gt;(),
</span><span>                vs: final_vs,
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Semigroup for </span><span style="color:#ffb964;">TimeSeries </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">combine</span><span>(&amp;</span><span style="color:#ffb964;">self</span><span>, </span><span style="color:#ffb964;">other</span><span>: &amp;</span><span style="color:#8fbfdc;">Self</span><span>) -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        combine_time_series(</span><span style="color:#ffb964;">self</span><span>, other)
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">impl </span><span>Monoid for </span><span style="color:#ffb964;">TimeSeries </span><span>{
</span><span>    </span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">empty</span><span>() -&gt; </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>        </span><span style="color:#8fbfdc;">Self </span><span>{
</span><span>            ts: vec![],
</span><span>            vs: vec![],
</span><span>        }
</span><span>    }
</span><span>}
</span></code></pre>
<p>时间序列可以是一种Monoid, 某个逻辑时间点上的值可能有缺失, 如何合并不同的time series， 时间序列类型上可以定义一些常见的操作.</p>
<p><a href="https://gist.github.com/unixisevil/badc8445d7a165d9abb8ec54147491e8">full source code</a></p>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://unixisevil.github.io/profile-rust/">Profiling Rust code using Samply</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2024-10-31
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/profile/">#profile</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/rust/">#rust</a>&nbsp;
                <a class="post-tag" href="https://unixisevil.github.io/tags/samply/">#samply</a></span>
    

                    
        <div class="post-content">
            <p>之前提到的<a href="https://blog.jola.dev/posts/elixir-string-processing-optimization">Elixir String Processing Optimization</a>文章中使用测试文本来自<a href="http://ptrace.fefe.de/wp/timings2019.txt">这里</a>, 这个链接张贴了多种语言实现的测试结果, 看了看其中rust 的实现, 一个是单线程的实现<a href="https://ptrace.fefe.de/wp/wpopt.rs">wpopt</a> , 另一个多线程的实现<a href="https://ptrace.fefe.de/wp/wp-rs.tar.xz">wp-rs</a>.</p>
<p>同时下载了C的实现<a href="https://ptrace.fefe.de/wp/wp2.c">wp2.c</a>,  编译后(gcc 11.4.0 , rustc 1.82.0), 测试对比了一下:</p>
<p>wp2:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: cat ./words-llvm8.0.txt | </span><span style="color:#ffb964;">./wp2
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      1.635 s ±  0.109 s    </span><span style="color:#8fbfdc;">[</span><span>User: 1.531 s, System: 0.194 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    1.505 s …  1.845 s    10 runs
</span></code></pre>
<p>wpopt:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: cat ../words-llvm8.0.txt | </span><span style="color:#ffb964;">./target/release/wpopt
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      2.065 s ±  0.018 s    </span><span style="color:#8fbfdc;">[</span><span>User: 1.732 s, System: 0.328 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    2.045 s …  2.105 s    10 runs
</span></code></pre>
<p><a href="https://github.com/mstange/samply/">samply</a> 的使用十分简单:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">samply</span><span> record ./my-application my-arguments
</span></code></pre>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">cat</span><span> ../words-llvm8.0.txt | </span><span style="color:#ffb964;">samply</span><span> record ./target/release/wpopt
</span></code></pre>
<p>命令执行后自动打开firefox 浏览器窗口:
<img src="/imgs/wpopt.samply.png"></p>
<p>从截图可以看出， 主要时间花费在hash table 相关， stdout 打印输出相关code.</p>
<p>当前rust的hash table 默认hash 算法是siphash, 有一定的防dos能力， 可是速度比较慢， 可以换成别的hash 算法, 比如<a href="https://crates.io/crates/rustc-hash">rustc_hash</a>, wp2 的实现也是使用比较普通的hash算法，wp2的实现缓冲stdout 的输出， wpopt.rs 也可以加上,  wp2 的实现已经假设文本是ascii 编码, rust 的String 类型是UTF-8 编码，带来少许开销, 可以使用Vec<u8>, &amp;[u8] 等替代.</p>
<p>wpopt_profile:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use rustc_hash::FxHashMap;
</span><span>use std::fs::File;
</span><span>use std::io::Write;
</span><span>use std::io::{</span><span style="color:#ffb964;">self</span><span>, Read};
</span><span>use std::iter::FromIterator;
</span><span>use std::os::fd::AsFd;
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() -&gt; io::Result&lt;()&gt; {
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> buffer = Vec::new();
</span><span>    io::stdin().read_to_end(&amp;</span><span style="color:#8fbfdc;">mut</span><span> buffer)?;
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> buffer = </span><span style="color:#8fbfdc;">unsafe </span><span>{ String::from_utf8_unchecked(buffer) };
</span><span>
</span><span>    </span><span style="color:#888888;">// Primitive Tokenize
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> frequency: FxHashMap&lt;&amp;</span><span style="color:#8fbfdc;">str</span><span>, </span><span style="color:#8fbfdc;">u32</span><span>&gt; = FxHashMap::default();
</span><span>    </span><span style="color:#8fbfdc;">for</span><span> word in buffer.split_ascii_whitespace() {
</span><span>        *frequency.entry(word).or_insert(</span><span style="color:#cf6a4c;">0</span><span>) += </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#888888;">// Sort by value
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> frequency = Vec::from_iter(frequency);
</span><span>    frequency.sort_by(|&amp;(_, </span><span style="color:#ffb964;">a</span><span>), &amp;(_, </span><span style="color:#ffb964;">b</span><span>)| b.cmp(&amp;a));
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> stdout = io::BufWriter::with_capacity(
</span><span>        </span><span style="color:#cf6a4c;">4096</span><span>,
</span><span>        File::from(io::stdout().as_fd().try_clone_to_owned().unwrap()),
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#888888;">// Push to stdout
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>(word, count) in frequency {
</span><span>        write!(&amp;mut stdout, </span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, format_args!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">{} {}\n</span><span style="color:#556633;">&quot;</span><span>, count, word))?;
</span><span>    }
</span><span>    Ok(())
</span><span>}
</span></code></pre>
<p>bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span>  </span><span style="color:#ffb964;">Benchmark</span><span> 1: cat ../words-llvm8.0.txt | </span><span style="color:#ffb964;">./target/release/wpopt_profile
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):      1.275 s ±  0.006 s    </span><span style="color:#8fbfdc;">[</span><span>User: 1.003 s, System: 0.265 s</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):    1.266 s …  1.285 s    10 runs
</span></code></pre>
<p>检查多线程的实现wp-rs 的时候，发现了其中的bug, 导致了单词被撕裂, 估计是不小心:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>.map(|</span><span style="color:#8fbfdc;">mut </span><span style="color:#ffb964;">pos</span><span>| {
</span><span>          </span><span style="color:#8fbfdc;">while</span><span> pos &lt; buffer_as_bytes.len() &amp;&amp; buffer_as_bytes[pos] == </span><span style="color:#556633;">&#39; &#39; </span><span>as </span><span style="color:#8fbfdc;">u8 </span><span>{
</span><span>              pos += </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>          }
</span><span>          pos
</span><span>      })
</span></code></pre>
<p>修复后的，bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span>   </span><span style="color:#ffb964;">Benchmark</span><span> 1: cat ../words-llvm8.0.txt | </span><span style="color:#ffb964;">./target/release/wp-rs
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):     678.2 ms ±   4.6 ms    </span><span style="color:#8fbfdc;">[</span><span>User: 2010.8 ms, System: 295.0 ms</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):   673.4 ms … 687.8 ms    10 runs                               
</span></code></pre>
<p>应用上面针对wpopt的优化策略后, 不过升级了hashbrown到0.15.0，从这个版本开始默认hash算法从siphash 切换成foldhash, 移除对itertools 的依赖, 标准库的reduce就可以实现foldl 操作了.</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::fs::File;
</span><span>use std::io::{</span><span style="color:#ffb964;">self</span><span>, Read, Write};
</span><span>use std::iter::{FromIterator, Iterator};
</span><span>use std::os::fd::AsFd;
</span><span>use std::str;
</span><span>use std::thread;
</span><span>
</span><span>use hashbrown::HashMap;
</span><span>
</span><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">Frequencies</span><span>&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>&gt; = HashMap&lt;&amp;</span><span style="color:#8fbfdc;">&#39;a str</span><span>, </span><span style="color:#8fbfdc;">usize</span><span>&gt;;
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() -&gt; io::Result&lt;()&gt; {
</span><span>    </span><span style="color:#888888;">// Read string from stdio
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> buffer = Vec::new();
</span><span>    io::stdin().read_to_end(&amp;</span><span style="color:#8fbfdc;">mut</span><span> buffer)?;
</span><span>
</span><span>    </span><span style="color:#888888;">// Figure out optimal chunk size
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> num_threads = num_cpus::get();
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> chunk_size = buffer.len() / num_threads;
</span><span>
</span><span>    </span><span style="color:#888888;">// Figure out positions where we can split string into chunks
</span><span>    </span><span style="color:#888888;">// We only split on whitespaces
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> split_positions: Vec&lt;_&gt; = (</span><span style="color:#cf6a4c;">0</span><span>..num_threads).map(|</span><span style="color:#ffb964;">i</span><span>| i * chunk_size).collect();
</span><span>    split_positions.push(buffer.len());
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> split_positions: Vec&lt;_&gt; = split_positions
</span><span>        .into_iter()
</span><span>        .map(|</span><span style="color:#8fbfdc;">mut </span><span style="color:#ffb964;">pos</span><span>| {
</span><span>            </span><span style="color:#8fbfdc;">while</span><span> pos &lt; buffer.len() &amp;&amp; buffer[pos] != </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&#39; &#39; </span><span>&amp;&amp; buffer[pos] != </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&#39;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&#39; </span><span>{
</span><span>                pos += </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>            }
</span><span>            pos
</span><span>        })
</span><span>        .collect();
</span><span>
</span><span>    </span><span style="color:#888888;">// Create references to seperate chunks
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> chunks = (</span><span style="color:#cf6a4c;">0</span><span>..num_threads).map(|</span><span style="color:#ffb964;">i</span><span>| {
</span><span>        buffer
</span><span>            .get(split_positions[i]..split_positions[i + </span><span style="color:#cf6a4c;">1</span><span>])
</span><span>            .unwrap()
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#888888;">// Tokenize each chunk on a seperate thread
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> frequencies: Result&lt;Vec&lt;_&gt;, _&gt; = thread::scope(|</span><span style="color:#ffb964;">s</span><span>| {
</span><span>        </span><span style="color:#8fbfdc;">let</span><span> threads: Vec&lt;_&gt; = chunks
</span><span>            .map(|</span><span style="color:#ffb964;">chunk</span><span>| {
</span><span>                s.spawn(</span><span style="color:#8fbfdc;">move </span><span>|| {
</span><span>                    </span><span style="color:#8fbfdc;">let mut</span><span> frequencies = Frequencies::new();
</span><span>                    </span><span style="color:#8fbfdc;">let</span><span> chunk = </span><span style="color:#8fbfdc;">unsafe </span><span>{ </span><span style="color:#8fbfdc;">str</span><span>::from_utf8_unchecked(chunk) };
</span><span>                    </span><span style="color:#8fbfdc;">for</span><span> word in chunk.split_ascii_whitespace() {
</span><span>                        *frequencies.entry(word).or_insert(</span><span style="color:#cf6a4c;">0</span><span>) += </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>                    }
</span><span>                    frequencies
</span><span>                })
</span><span>            })
</span><span>            .collect();
</span><span>
</span><span>        threads.into_iter().map(|</span><span style="color:#ffb964;">t</span><span>| t.join()).collect()
</span><span>    });
</span><span>
</span><span>    </span><span style="color:#888888;">// Merge results from each thread into a single HashMap
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> frequencies = frequencies.unwrap();
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> frequencies = frequencies
</span><span>        .into_iter()
</span><span>        .reduce(merge_frequencies)
</span><span>        .unwrap_or_default();
</span><span>
</span><span>    </span><span style="color:#888888;">// Sort by value
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> frequencies = Vec::from_iter(frequencies);
</span><span>    frequencies.sort_by(|&amp;(_, </span><span style="color:#ffb964;">a</span><span>), &amp;(_, </span><span style="color:#ffb964;">b</span><span>)| b.cmp(&amp;a));
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> stdout = io::stdout();
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> stdout = io::BufWriter::with_capacity(
</span><span>        </span><span style="color:#cf6a4c;">65536</span><span>,
</span><span>        File::from(stdout.as_fd().try_clone_to_owned().unwrap()),
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#888888;">// Push to stdout
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>(word, count) in frequencies {
</span><span>        write!(&amp;mut stdout, </span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, format_args!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">{} {}\n</span><span style="color:#556633;">&quot;</span><span>, count, word))?;
</span><span>    }
</span><span>
</span><span>    Ok(())
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">merge_frequencies</span><span>&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>&gt;(</span><span style="color:#8fbfdc;">mut </span><span style="color:#ffb964;">a</span><span>: Frequencies&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>&gt;, </span><span style="color:#ffb964;">b</span><span>: Frequencies&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>&gt;) -&gt; Frequencies&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>&gt; {
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>(word, count) in b {
</span><span>        *a.entry(word).or_insert(</span><span style="color:#cf6a4c;">0</span><span>) += count
</span><span>    }
</span><span>    a
</span><span>}                                                                                  
</span></code></pre>
<p>bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span> </span><span style="color:#ffb964;">Benchmark</span><span> 1: cat ../words-llvm8.0.txt | </span><span style="color:#ffb964;">./target/release/wp-rs-profile
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):     594.6 ms ±   3.2 ms    </span><span style="color:#8fbfdc;">[</span><span>User: 1529.0 ms, System: 289.9 ms</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):   590.5 ms … 599.8 ms    10 runs 
</span></code></pre>
<p>Update:  rust的数据并行处理库<a href="https://docs.rs/rayon/latest/rayon/">rayon</a>, 可能和elixir的<a href="https://hexdocs.pm/flow/Flow.html">flow</a> 比较类似，尝试使用rayon写同样的测试code:</p>
<pre data-lang="rust" style="background-color:#151515;color:#e8e8d3;" class="language-rust "><code class="language-rust" data-lang="rust"><span>use std::fs::File;
</span><span>use std::io::{</span><span style="color:#ffb964;">self</span><span>, Read, Write};
</span><span>use std::os::fd::AsFd;
</span><span>use std::str;
</span><span>
</span><span>use hashbrown::HashMap;
</span><span>use rayon::prelude::*;
</span><span>
</span><span style="color:#8fbfdc;">type </span><span style="color:#ffb964;">Frequencies</span><span>&lt;</span><span style="color:#8fbfdc;">&#39;a</span><span>&gt; = HashMap&lt;&amp;</span><span style="color:#8fbfdc;">&#39;a str</span><span>, </span><span style="color:#8fbfdc;">usize</span><span>&gt;;
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">main</span><span>() -&gt; io::Result&lt;()&gt; {
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> buffer = Vec::new();
</span><span>    io::stdin().read_to_end(&amp;</span><span style="color:#8fbfdc;">mut</span><span> buffer)?;
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> positions = even_parts_positions(buffer.len(), rayon::current_num_threads());
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> wcs = positions
</span><span>        .into_par_iter()
</span><span>        .map(|</span><span style="color:#8fbfdc;">mut </span><span style="color:#ffb964;">pos</span><span>| {
</span><span>            </span><span style="color:#8fbfdc;">while</span><span> pos &lt; buffer.len() &amp;&amp; buffer[pos] != </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&#39; &#39; </span><span>&amp;&amp; buffer[pos] != </span><span style="color:#8fbfdc;">b</span><span style="color:#556633;">&#39;</span><span style="color:#99ad6a;">\n</span><span style="color:#556633;">&#39; </span><span>{
</span><span>                pos += </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>            }
</span><span>            pos
</span><span>        })
</span><span>        .collect::&lt;Vec&lt;_&gt;&gt;()
</span><span>        .par_windows(</span><span style="color:#cf6a4c;">2</span><span>)
</span><span>        .fold(
</span><span>            </span><span style="color:#888888;">//Frequencies::new,
</span><span>            || Frequencies::with_capacity(</span><span style="color:#cf6a4c;">50021</span><span>),
</span><span>            |</span><span style="color:#8fbfdc;">mut </span><span style="color:#ffb964;">m</span><span>: Frequencies, </span><span style="color:#ffb964;">r</span><span>: &amp;[</span><span style="color:#8fbfdc;">usize</span><span>]| {
</span><span>                </span><span style="color:#8fbfdc;">let</span><span> chunk = </span><span style="color:#8fbfdc;">unsafe </span><span>{ </span><span style="color:#8fbfdc;">str</span><span>::from_utf8_unchecked(&amp;buffer[r[</span><span style="color:#cf6a4c;">0</span><span>]..r[</span><span style="color:#cf6a4c;">1</span><span>]]) };
</span><span>                </span><span style="color:#8fbfdc;">for</span><span> word in chunk.split_ascii_whitespace() {
</span><span>                    *m.entry(word).or_insert(</span><span style="color:#cf6a4c;">0</span><span>) += </span><span style="color:#cf6a4c;">1</span><span>;
</span><span>                }
</span><span>                m
</span><span>            },
</span><span>        )
</span><span>        .reduce(
</span><span>            </span><span style="color:#888888;">//Frequencies::new,
</span><span>            || Frequencies::with_capacity(</span><span style="color:#cf6a4c;">557733</span><span>),
</span><span>            |</span><span style="color:#8fbfdc;">mut </span><span style="color:#ffb964;">acc</span><span>: Frequencies, </span><span style="color:#ffb964;">m</span><span>: Frequencies| {
</span><span>                </span><span style="color:#8fbfdc;">for </span><span>(word, count) in m {
</span><span>                    *acc.entry(word).or_insert(</span><span style="color:#cf6a4c;">0</span><span>) += count
</span><span>                }
</span><span>                acc
</span><span>            },
</span><span>        )
</span><span>        .into_par_iter()
</span><span>        .collect::&lt;Vec&lt;(_, _)&gt;&gt;();
</span><span>
</span><span>    wcs.par_sort_unstable_by(|&amp;(_, </span><span style="color:#ffb964;">a</span><span>), &amp;(_, </span><span style="color:#ffb964;">b</span><span>)| b.cmp(&amp;a));
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> stdout = io::BufWriter::with_capacity(
</span><span>        </span><span style="color:#cf6a4c;">65536</span><span>,
</span><span>        File::from(io::stdout().as_fd().try_clone_to_owned().unwrap()),
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">for </span><span>(w, c) in wcs {
</span><span>        write!(&amp;mut stdout, </span><span style="color:#556633;">&quot;</span><span style="color:#7697d6;">{}</span><span style="color:#556633;">&quot;</span><span>, format_args!(</span><span style="color:#556633;">&quot;</span><span style="color:#99ad6a;">{} {}\n</span><span style="color:#556633;">&quot;</span><span>, c, w))?;
</span><span>    }
</span><span>    Ok(())
</span><span>}
</span><span>
</span><span style="color:#8fbfdc;">fn </span><span style="color:#fad07a;">even_parts_positions</span><span>(</span><span style="color:#ffb964;">n</span><span>: </span><span style="color:#8fbfdc;">usize</span><span>, </span><span style="color:#ffb964;">p</span><span>: </span><span style="color:#8fbfdc;">usize</span><span>) -&gt; Vec&lt;</span><span style="color:#8fbfdc;">usize</span><span>&gt; {
</span><span>    assert!(n &gt;= p);
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> r = n % p;
</span><span>    </span><span style="color:#8fbfdc;">let</span><span> d = (n - r) / p;
</span><span>    </span><span style="color:#8fbfdc;">let mut</span><span> ret = vec![</span><span style="color:#cf6a4c;">0</span><span style="color:#8fbfdc;">usize</span><span>; p + </span><span style="color:#cf6a4c;">1</span><span>];
</span><span>
</span><span>    </span><span style="color:#8fbfdc;">for</span><span> i in </span><span style="color:#cf6a4c;">1</span><span>..=p - r {
</span><span>        ret[i] = i * d
</span><span>    }
</span><span>    </span><span style="color:#8fbfdc;">for</span><span> i in p - r + </span><span style="color:#cf6a4c;">1</span><span>..p + </span><span style="color:#cf6a4c;">1 </span><span>{
</span><span>        ret[i] = ret[i - </span><span style="color:#cf6a4c;">1</span><span>] + (d + </span><span style="color:#cf6a4c;">1</span><span>)
</span><span>    }
</span><span>    ret
</span><span>}
</span></code></pre>
<p>bench 结果:</p>
<pre data-lang="bash" style="background-color:#151515;color:#e8e8d3;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#ffb964;">Benchmark</span><span> 1: cat ../words-llvm8.0.txt | </span><span style="color:#ffb964;">./target/release/wf-rayon
</span><span>  </span><span style="color:#ffb964;">Time</span><span> (mean ± σ):     580.6 ms ±   2.1 ms    </span><span style="color:#8fbfdc;">[</span><span>User: 1881.9 ms, System: 411.3 ms</span><span style="color:#8fbfdc;">]
</span><span>  </span><span style="color:#ffb964;">Range</span><span> (min … max):   578.0 ms … 583.2 ms    10 runs
</span></code></pre>

        </div>

                </div>
            <div class="pagination">
                <div class="pagination__buttons">
                    <span class="button previous">
                        <a href="https://unixisevil.github.io/">
                            <span class="button__icon">←</span>&nbsp;
                            <span class="button__text">Newer posts</span>
                        </a>
                    </span>
                
                    <span class="button next">
                        <a href="https://unixisevil.github.io/page/3/">
                            <span class="button__text">Older posts</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
            </div>
        </div>
        
    </div>

    
    <footer class="footer">
        <div class="footer__inner">
                <div class="copyright">
                        <span>© 
    2025
 Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    <span class="copyright-theme">
                        <span class="copyright-theme-sep">:: </span>
                        Theme: <a href="https://github.com/pawroman/zola-theme-terminimal/">Terminimal</a> by pawroman
                    </span>
                </div>
            </div>
    </footer>
    

</div>
</body>

</html>
